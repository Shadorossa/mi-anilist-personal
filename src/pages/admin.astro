---
import { supabase } from "../lib/supabase";
import "../styles/Asearch.css";

import Sidebar from "../components/admin/Sidebar.astro";
import SearchPanel from "../components/admin/SearchPanel.astro";
import LibraryPanel from "../components/admin/LibraryPanel.astro";
import CharacterPanel from "../components/admin/CharacterPanel.astro";
import MyCharactersPanel from "../components/admin/MyCharactersPanel.astro";
import FavoritesPanel from "../components/admin/FavoritesPanel.astro";
import SagasPanel from "../components/admin/SagasPanel.astro";
import ImageManagerPanel from "../components/admin/ImageManagerPanel.astro";
import EditorModal from "../components/admin/EditorModal.astro";
import MusicSearchPanel from "../components/admin/MusicSearchPanel.astro";
import MyMusicPanel from "../components/admin/MyMusicPanel.astro";
import CharacterModal from "../components/admin/CharacterModal.astro";
import SagaCoverPickerModal from "../components/admin/SagaCoverPickerModal.astro";

// --- 1. OBTENER TODOS LOS DATOS DESDE SUPABASE ---
const [
    worksRes,
    favoritesRes,
    monthlyPicksRes,
    charactersRes,
    monthlyCharsRes,
    sagasRes,
    musicRes,
] = await Promise.all([
    supabase.from("works").select("*"),
    supabase.from("favorites").select("is_saga, title, cover").order("order"),
    supabase.from("monthly_picks").select("month, work_title, cover"),
    supabase.from("characters").select("*"),
    supabase.from("monthly_chars").select("month, char_name, cover"),
    supabase.from("sagas").select("name, work_titles"),
    supabase.from("music").select("*"),
]);

// --- 2. PROCESAR Y ESTRUCTURAR LOS DATOS ---
const localLibrary = worksRes.data || [];
const localMusic = musicRes.data || [];

const sagasMap = (sagasRes.data || []).reduce((acc, saga) => {
    acc[saga.name] = saga.work_titles;
    return acc;
}, {});

const allCharacters = charactersRes.data || [];
const charactersByCategory = {
    hall_of_fame: allCharacters
        .filter((c) => c.category === "hall_of_fame")
        .sort((a, b) => (a.order ?? 0) - (b.order ?? 0)),
    liked: allCharacters.filter((c) => c.category === "liked"),
    interested: allCharacters.filter((c) => c.category === "interested"),
    disliked: allCharacters.filter((c) => c.category === "disliked"),
};

// Recrear el objeto `db` en el formato que espera el script del cliente
const db = {
    favorites: favoritesRes.data || [],
    monthlyPicks: (monthlyPicksRes.data || []).map((p) => ({
        month: p.month,
        title: p.work_title,
        cover: p.cover,
    })),
    characters: charactersByCategory.hall_of_fame,
    monthlyChars: (monthlyCharsRes.data || []).map((p) => ({
        month: p.month,
        name: p.char_name,
        cover: p.cover,
    })),
    likedCharacters: charactersByCategory.liked,
    interestedCharacters: charactersByCategory.interested,
    dislikedCharacters: charactersByCategory.disliked,
    sagas: sagasMap,
};

// El gestor de imágenes basado en `fs` se elimina. No es fiable en un entorno serverless.
// Por ahora, pasamos arrays vacíos.
const allImages = [];
const unusedImages = [];

// La lógica de `favoritesOrdered` se actualiza para manejar el nuevo formato de `db.favorites`
const favoritesOrdered = (db.favorites || [])
    .map((fav) => {
        if (fav.is_saga) {
            return fav; // Pasa los objetos de saga directamente
        }
        // Busca la obra en la biblioteca por título
        return localLibrary.find((item) => item.title === fav.title);
    })
    .filter(Boolean);
---

<html lang="es" class="dark">
    <head>
        <title>Nexus Admin</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
        />
        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"
        ></script>
    </head>
    <body>
        <Sidebar />

        <main class="admin-main">
            <SearchPanel />
            <LibraryPanel />
            <CharacterPanel />
            <MyCharactersPanel />
            <FavoritesPanel />
            <SagasPanel />
            <ImageManagerPanel />
            <MusicSearchPanel />
            <MyMusicPanel />
        </main>

        <EditorModal />
        <CharacterModal />
        <SagaCoverPickerModal />

        <!-- NUEVO: Modal para seleccionar obra de origen del personaje -->
        <div
            id="work-picker-modal"
            class="hidden fixed inset-0 z-[80] flex items-center justify-center p-4 bg-black/90 backdrop-blur-md"
        >
            <div
                class="bg-[#0c0c0e] border border-white/10 w-full max-w-4xl rounded-3xl shadow-2xl p-6 relative flex flex-col max-h-[80vh]"
            >
                <button
                    onclick="closeWorkPicker()"
                    class="absolute top-4 right-4 w-8 h-8 flex items-center justify-center bg-black/50 text-white rounded-full hover:bg-white hover:text-black transition z-20"
                    ><i class="fa-solid fa-xmark"></i></button
                >
                <h3 class="text-lg font-bold text-white mb-4 shrink-0">
                    Selecciona la obra de origen
                </h3>
                <input
                    type="text"
                    id="workPickerFilter"
                    placeholder="Buscar obra..."
                    class="form-input !w-full !mb-4"
                />
                <div class="custom-scrollbar flex-1">
                    <div id="work-picker-grid" class="asearch-grid"></div>
                </div>
            </div>
        </div>

        <!-- NUEVO: Modal para editar offsets de personajes en masa -->
        <div
            id="bulk-offset-editor-modal"
            class="hidden fixed inset-0 z-[90] flex items-center justify-center p-4 bg-black/90 backdrop-blur-md"
        >
            <div
                class="bg-[#0c0c0e] border border-white/10 w-full max-w-7xl rounded-3xl shadow-2xl p-6 relative flex flex-col max-h-[90vh]"
            >
                <div class="flex items-center justify-between mb-4 shrink-0">
                    <h3 class="text-lg font-bold text-white">
                        Editor de Offsets en Masa
                    </h3>
                    <div class="flex items-center gap-4">
                        <button
                            id="save-bulk-offsets-btn"
                            onclick="saveBulkOffsets()"
                            class="bg-green-600 text-white font-bold px-4 py-2 rounded-lg hover:bg-green-500 transition text-xs uppercase tracking-wide"
                            >Guardar Cambios</button
                        >
                        <button
                            onclick="closeBulkOffsetEditor()"
                            class="w-8 h-8 flex items-center justify-center bg-black/50 text-white rounded-full hover:bg-white hover:text-black transition"
                            ><i class="fa-solid fa-xmark"></i></button
                        >
                    </div>
                </div>
                <div class="custom-scrollbar flex-1">
                    <div
                        id="bulk-offset-grid"
                        class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 2xl:grid-cols-6 gap-4"
                    >
                    </div>
                </div>
            </div>
        </div>

        <!-- Modal para cambiar imagen por URL con preview -->
        <div
            id="url-image-changer-modal"
            class="hidden fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/90 backdrop-blur-md"
        >
            <div
                class="bg-[#0c0c0e] border border-white/10 w-full max-w-lg rounded-3xl shadow-2xl p-6 relative flex flex-col gap-4"
            >
                <h3 class="text-lg font-bold text-white">
                    Cambiar Imagen por URL
                </h3>

                <div class="relative">
                    <label for="imageUrlInput" class="form-label"
                        >URL de la imagen</label
                    >
                    <input
                        type="text"
                        id="imageUrlInput"
                        placeholder="https://..."
                        class="form-input !pr-10"
                    />
                    <button
                        onclick="pasteFromClipboard()"
                        class="absolute top-7 right-2 w-7 h-7 flex items-center justify-center text-gray-500 hover:text-white"
                        title="Pegar desde portapapeles"
                    >
                        <i class="fa-solid fa-paste text-xs"></i>
                    </button>
                </div>

                <div>
                    <label class="form-label">Vista Previa</label>
                    <div
                        class="w-full aspect-video bg-[#121215] border border-white/10 rounded-lg flex items-center justify-center overflow-hidden"
                    >
                        <img
                            id="imageUrlPreview"
                            src=""
                            alt="Vista previa"
                            class="max-w-full max-h-full object-contain hidden"
                        />
                        <span
                            id="imageUrlPreviewPlaceholder"
                            class="text-xs text-gray-600"
                            >Pega una URL para ver la imagen</span
                        >
                    </div>
                </div>

                <div class="flex items-center justify-end gap-4 mt-4">
                    <button
                        onclick="closeUrlImageChanger()"
                        class="text-gray-400 font-bold text-xs uppercase tracking-wider px-4 py-2 rounded-lg hover:text-white transition"
                        >Cancelar</button
                    >
                    <button
                        id="saveUrlImageBtn"
                        onclick="saveNewUrlImage()"
                        class="bg-indigo-600 text-white font-bold px-6 py-2 rounded-lg hover:bg-indigo-500 transition text-xs uppercase tracking-wide"
                        >Guardar Imagen</button
                    >
                </div>
            </div>
        </div>

        <script
            define:vars={{
                localLibrary,
                favoritesOrdered,
                db,
                allImages,
                unusedImages,
                localMusic,
            }}
        >
            window.localLibrary = localLibrary;
            window.favoritesList = favoritesOrdered;
            window.favoritesTitles = db.favorites || [];
            window.monthlyPicksGlobal = db.monthlyPicks || [];
            window.charactersGlobal = db.characters || [];
            window.monthlyCharsGlobal = db.monthlyChars || [];
            window.likedCharactersGlobal = db.likedCharacters || [];
            window.sagas = db.sagas || {};
            window.interestedCharactersGlobal = db.interestedCharacters || [];
            window.dislikedCharactersGlobal = db.dislikedCharacters || [];
            window.allImages = allImages;
            window.unusedImages = unusedImages;
            window.localMusic = localMusic;
        </script>

        <!-- Script para restaurar el estado de la página -->
        <script>
            const previousActiveTab =
                localStorage.getItem("activeTab") || "search";
        </script>
        <script type="module">
            import { calculateRating } from "/src/utils/rating.js";
            window.calculateRating = calculateRating;
        </script>

        <script is:inline>
            // CSS para el panel de sagas
            // NOTA: Recuerda añadir un botón en Sidebar.astro para activar el panel 'images'
            // NOTA: Recuerda añadir botones en Sidebar.astro para 'music-search' y 'my-music'
            // ej: <button onclick="switchMode('images')" ...><i class="fa-solid fa-images"></i></button>

            const sagaStyles = `
                .saga-list {
                    background-color: rgba(255,255,255,0.02);
                    border: 1px solid rgba(255,255,255,0.05);
                    border-radius: 8px;
                    padding: 6px;
                    min-height: 108px; /* Acomoda la altura de las portadas (64 * 1.5 + padding) */
                    display: flex;
                    gap: 6px;
                    overflow-x: auto;
                    flex-wrap: nowrap;
                    scroll-snap-type: x mandatory;
                    scrollbar-width: none; /* Firefox */
                }
                .saga-list::-webkit-scrollbar { display: none; } /* Chrome, Safari */
                .saga-item {
                    position: relative;
                    aspect-ratio: 2 / 3;
                    width: 64px;
                    flex-shrink: 0;
                    border-radius: 4px;
                    cursor: grab;
                    overflow: hidden;
                    border: 1px solid rgba(255,255,255,0.1);
                    scroll-snap-align: start;
                }
                .saga-item-cover { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; }
                .saga-item.sortable-ghost { background: #6366f1; opacity: 0.5; }
                .saga-container {
                    position: relative;
                    overflow: visible; /* Asegura que el marcador se vea fuera */
                    background-color: #0c0c0e; border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 8px;
                }
                .saga-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
                .saga-title-input { background: transparent; color: white; font-weight: bold; border: none; outline: none; width: 100%; font-size: 13px; }
                .delete-saga-btn { color: #71717a; cursor: pointer; }
                .delete-saga-btn:hover { color: #f87171; }

                /* Estilos para el picker de meses deshabilitado */
                .saga-tag-strip {
                    position: relative;
                    width: 8px;
                    height: 16px;
                    border-radius: 3px;
                    cursor: help;
                    transition: all 0.2s ease-in-out;
                    flex-shrink: 0;
                }
                .saga-tag-strip:hover {
                    transform: scale(1.15);
                }
                .saga-tag-strip::after {
                    content: attr(data-tag-text); 
                    position: absolute;
                    bottom: 140%;
                    left: 50%;
                    transform: translateX(-50%) scale(0.9);
                    background: #1e1e21;
                    color: #e4e4e7;
                    padding: 4px 10px;
                    border-radius: 6px;
                    font-size: 10px;
                    font-weight: 700;
                    text-transform: uppercase;
                    white-space: nowrap;
                    opacity: 0;
                    visibility: hidden;
                    pointer-events: none;
                    transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
                    z-index: 10;
                    border: 1px solid rgba(255,255,255,0.1);
                    box-shadow: 0 5px 15px rgba(0,0,0,0.5);
                }
                .saga-tag-strip:hover::after {
                    opacity: 1;
                    visibility: visible;
                    pointer-events: auto;
                    transform: translateX(-50%) scale(1);
                }
                .saga-tag-strip.saga-tag--franchise { background-color: #6d28d9; }
                .saga-tag-strip.saga-tag--adaptation { background-color: #0369a1; }
                .saga-tag-strip.saga-tag--complete { background-color: #166534; }
                .saga-tag-strip.saga-tag--saga { background-color: #991b1b; }
                .month-btn-item.disabled {
                    background: rgba(255, 255, 255, 0.02);
                    color: #404040;
                    cursor: not-allowed;
                    border-color: rgba(255, 255, 255, 0.03);
                    text-decoration: line-through;
                    text-decoration-color: rgba(239, 68, 68, 0.4);
                }
                .month-btn-item.disabled:hover {
                    background: rgba(255, 255, 255, 0.02);
                    color: #404040;
                }
            `;

            const styleSheet = document.createElement("style");
            styleSheet.innerText = sagaStyles;
            document.head.appendChild(styleSheet);

            // La función de acordeón ya no es necesaria con el nuevo layout
            window.toggleAccordion = () => {};
            window.toggleSagaFavorite = (sagaName, starIcon) => {
                const favIndex = window.favoritesTitles.findIndex(
                    (fav) =>
                        fav &&
                        (fav.is_saga || fav.isSaga) &&
                        fav.title === sagaName,
                );
                if (favIndex > -1) {
                    window.favoritesTitles.splice(favIndex, 1);
                    starIcon.classList.remove("text-yellow-400");
                    starIcon.classList.add(
                        "text-gray-600",
                        "hover:text-yellow-400",
                    );
                } else {
                    openSagaCoverPicker(sagaName);
                }
            };
            window.openSagaCoverPicker = (sagaName) => {
                const modal = document.getElementById(
                    "saga-cover-picker-modal",
                );
                const grid = document.getElementById("saga-picker-grid");
                const title = document.getElementById("saga-picker-title");

                const gamesInSaga = window.sagas[sagaName];
                if (!gamesInSaga || gamesInSaga.length === 0) {
                    alert(
                        "Esta saga no tiene juegos. Añade juegos a la saga primero.",
                    );
                    return;
                }

                title.innerText = `Elige una portada para la saga "${sagaName}"`;

                grid.innerHTML = gamesInSaga
                    .map((gameTitle) => {
                        const game = window.localLibrary.find(
                            (item) => item.title === gameTitle,
                        );
                        if (!game) return "";
                        return `
                        <div class="asearch-card" onclick="selectSagaCover('${sagaName}', '${game.cover}')">
                            <img src="${game.cover}" loading="lazy">
                            <div class="asearch-info">
                                <h4 class="asearch-title">${game.title}</h4>
                            </div>
                        </div>
                    `;
                    })
                    .join("");

                modal.classList.remove("hidden");
            };

            window.selectSagaCover = (sagaName, coverUrl) => {
                const sagaFavObject = {
                    isSaga: true,
                    is_saga: true,
                    title: sagaName,
                    cover: coverUrl,
                };
                window.favoritesTitles.push(sagaFavObject);

                const starIcon = document.querySelector(
                    `i[onclick*="'${sagaName}'"]`,
                );
                if (starIcon) {
                    starIcon.classList.add("text-yellow-400");
                    starIcon.classList.remove(
                        "text-gray-600",
                        "hover:text-yellow-400",
                    );
                }

                document
                    .getElementById("saga-cover-picker-modal")
                    .classList.add("hidden");
            };

            let currentSelection = null;
            let isFavorite = false;
            let currentPickYear = new Date().getFullYear();
            let currentCharPickYear = new Date().getFullYear();
            let activeCharCategory = "fav";
            let activeCharListSortable = null;
            // State for Bulk Editing
            let isBulkEditing = false; // For works
            let selectedItemIds = new Set(); // For works
            let isCharBulkEditing = false; // For characters
            let selectedCharIds = new Set(); // For characters
            let isBulkSourcePicking = false; // Flag for work picker
            let tempOffsetMap = new Map(); // For the new bulk offset editor
            let hideAssignedChars = false;
            // --- Lógica para ordenación de la biblioteca local ---
            let localCurrentSort = "saga";
            let localIsAscending = false;

            // Busca esta función en tu <script is:inline>
            window.handleCardClick = (actionName, encodedItem) => {
                if (!actionName) return; // No hacer nada si no hay acción
                try {
                    const item = JSON.parse(decodeURIComponent(encodedItem));

                    // Abrir editores de obras
                    if (actionName === "openEditorSearch")
                        openEditorSearch(item);
                    if (actionName === "openEditorMusic") openEditorMusic(item);
                    if (actionName === "openEditorLocal") openEditorLocal(item);

                    // --- ESTA ES LA LÍNEA QUE TE FALTA ---
                    if (actionName === "openCharEditor") openCharEditor(item);
                } catch (e) {
                    console.error("Error al procesar el click:", e);
                }
            };

            window.toggleHideAssigned = () => {
                hideAssignedChars = !hideAssignedChars;
                const btn = document.getElementById("char-hide-assigned-btn");
                if (hideAssignedChars) {
                    btn.classList.add("bg-indigo-500/20", "text-indigo-300");
                } else {
                    btn.classList.remove("bg-indigo-500/20", "text-indigo-300");
                }
                renderMyCharacters(
                    document.getElementById("myCharsFilter").value,
                );
            };

            // --- Character Bulk Edit Functions ---
            window.toggleCharBulkEditMode = (forceState) => {
                isCharBulkEditing =
                    typeof forceState === "boolean"
                        ? forceState
                        : !isCharBulkEditing;
                const btn = document.getElementById("char-bulk-edit-btn");
                const selectAllBtn = document.getElementById(
                    "char-select-all-btn",
                );
                const grid = document.getElementById("myCharsGrid");

                if (isCharBulkEditing) {
                    btn.classList.add("bg-indigo-500/20", "text-indigo-300");
                    selectAllBtn.classList.remove("hidden");
                    grid.classList.add("bulk-editing");
                } else {
                    btn.classList.remove("bg-indigo-500/20", "text-indigo-300");
                    selectAllBtn.classList.add("hidden");
                    grid.classList.remove("bulk-editing");
                    selectedCharIds.clear();
                }
                updateCharBulkActionBar();
                renderMyCharacters(
                    document.getElementById("myCharsFilter").value,
                );
            };

            window.toggleSelectAllChars = () => {
                const allVisibleCards = document.querySelectorAll(
                    "#myCharsGrid .asearch-card",
                );
                const allVisibleIds = Array.from(allVisibleCards).map((card) =>
                    String(card.dataset.id),
                );

                const allAreSelected =
                    allVisibleIds.length > 0 &&
                    allVisibleIds.every((id) => selectedCharIds.has(id));

                if (allAreSelected) {
                    // Deseleccionar todos los visibles
                    allVisibleIds.forEach((id) => {
                        selectedCharIds.delete(id);
                        const card = document.querySelector(
                            `.asearch-card[data-id='${id}']`,
                        );
                        card?.classList.remove("selected");
                    });
                } else {
                    // Seleccionar todos los visibles
                    allVisibleIds.forEach((id) => {
                        selectedCharIds.add(id);
                        const card = document.querySelector(
                            `.asearch-card[data-id='${id}']`,
                        );
                        card?.classList.add("selected");
                    });
                }
                updateCharBulkActionBar();
            };

            window.toggleCharItemSelection = (charId) => {
                if (!isCharBulkEditing) return;
                const card = document.querySelector(
                    `.asearch-card[data-id='${charId}']`,
                );
                if (selectedCharIds.has(charId)) {
                    selectedCharIds.delete(charId);
                    card?.classList.remove("selected");
                } else {
                    selectedCharIds.add(charId);
                    card?.classList.add("selected");
                }
                updateCharBulkActionBar();
            };

            function updateCharBulkActionBar() {
                const bar = document.getElementById("char-bulk-action-bar");
                const countEl = document.getElementById("char-bulk-count");
                if (isCharBulkEditing && selectedCharIds.size > 0) {
                    bar.classList.remove("hidden");
                    countEl.textContent = `${selectedCharIds.size} seleccionados`;
                } else {
                    bar.classList.add("hidden");
                }
            }

            window.openBulkSourceChanger = () => {
                isBulkSourcePicking = true;
                openWorkPicker();
            };

            async function applyBulkSourceChange(workId) {
                const bar = document.getElementById("char-bulk-action-bar");
                const originalHTML = bar.innerHTML;
                bar.innerHTML = `<div class="flex items-center gap-2 px-4 py-2"><i class="fa-solid fa-circle-notch fa-spin text-white"></i><span class="text-xs text-gray-400">Aplicando...</span></div>`;

                const payload = {
                    ids: Array.from(selectedCharIds),
                    source_id: workId,
                };

                try {
                    const res = await fetch("/api/bulk-char-update.json", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(payload),
                    });
                    if (res.ok) {
                        // 1. Actualizar los datos locales en memoria
                        const allCharLists = [
                            window.charactersGlobal,
                            window.likedCharactersGlobal,
                            window.interestedCharactersGlobal,
                            window.dislikedCharactersGlobal,
                        ];

                        selectedCharIds.forEach((charId) => {
                            for (const list of allCharLists) {
                                const char = list.find((c) => c.id == charId);
                                if (char) {
                                    char.source_id = workId;
                                    char.sourceId = workId; // Actualizar ambos para consistencia
                                    break;
                                }
                            }
                        });

                        // 2. Mostrar mensaje de éxito en la barra de acciones
                        bar.innerHTML = `<div class="flex items-center gap-2 px-4 py-2"><i class="fa-solid fa-check text-green-400"></i><span class="text-xs text-green-400">¡Actualizado!</span></div>`;

                        // 3. Re-renderizar la parrilla para mostrar los cambios inmediatamente
                        renderMyCharacters(
                            document.getElementById("myCharsFilter").value,
                        );

                        // 4. Después de un momento, salir del modo de edición masiva
                        setTimeout(() => {
                            toggleCharBulkEditMode(false);
                            // Restaurar el contenido original de la barra para el próximo uso
                            bar.innerHTML = originalHTML;
                        }, 1500);
                    } else {
                        const errorData = await res.json();
                        throw new Error(
                            errorData.error || "Bulk character update failed",
                        );
                    }
                } catch (e) {
                    console.error(e);
                    alert("Error al actualizar los personajes.");
                    bar.innerHTML = originalHTML; // Restore on error
                } finally {
                    isBulkSourcePicking = false;
                    closeWorkPicker();
                }
            }

            // --- Bulk Offset Editor Functions ---
            window.openBulkOffsetEditor = () => {
                const modal = document.getElementById(
                    "bulk-offset-editor-modal",
                );
                const grid = document.getElementById("bulk-offset-grid");
                if (!modal || !grid) return;

                tempOffsetMap.clear();
                grid.innerHTML = ""; // Limpiar contenido previo

                const allCharLists = [
                    ...window.charactersGlobal,
                    ...window.likedCharactersGlobal,
                    ...window.interestedCharactersGlobal,
                    ...window.dislikedCharactersGlobal,
                ];
                const selectedChars = Array.from(selectedCharIds)
                    .map((id) => allCharLists.find((c) => c.id == id))
                    .filter(Boolean);

                selectedChars.forEach((char) => {
                    const charId = String(char.id);
                    const currentOffset =
                        char.cover_offset_y ?? char.coverOffsetY ?? 50;
                    tempOffsetMap.set(charId, currentOffset);

                    const cardHTML = `
                        <div class="bg-[#121215] border border-white/5 rounded-lg p-2 group flex flex-col select-none gap-2">
                            <div class="flex gap-2 h-10 shrink-0">
                                <div class="w-10 bg-[#0a0a0c] rounded border border-white/5 flex flex-col items-center justify-center shrink-0">
                                    <span class="text-[8px] text-gray-500 font-bold leading-none mb-0.5">PREV</span>
                                    <span class="text-[9px] text-pink-400 font-black leading-none tracking-wide">VIEW</span>
                                </div>
                                <div class="flex-1 relative rounded overflow-hidden shadow-sm">
                                    <img id="bulk-offset-preview-${charId}" src="${char.cover}" class="absolute inset-0 w-full h-full object-cover" style="object-position: center ${currentOffset}%;" />
                                </div>
                                <!-- Vertical Slider next to image -->
                                <div id="bulk-offset-slider-container-${charId}" class="relative h-10 w-4 flex justify-center cursor-pointer">
                                    <div class="w-1 h-full bg-white/10 rounded-full"></div>
                                    <div id="bulk-offset-slider-thumb-${charId}" class="absolute w-4 h-4 bg-pink-500 rounded-full cursor-grab" style="top: calc(${100 - currentOffset}% - 8px);"></div>
                                </div>
                            </div>
                            <div class="flex items-center justify-between px-0.5 min-h-[24px]">
                                <h4 class="text-[10px] font-bold text-gray-400 leading-tight text-left line-clamp-2 flex-1" title="${char.title}">${char.title}</h4>
                                <span id="bulk-offset-text-${charId}" class="text-white text-[10px] font-bold bg-white/10 px-2 py-0.5 rounded w-12 text-center">${currentOffset}%</span>
                            </div>
                        </div>
                    `;
                    grid.insertAdjacentHTML("beforeend", cardHTML);
                });

                setTimeout(() => {
                    selectedChars.forEach((char) => {
                        const charId = String(char.id);
                        initCustomSlider(
                            `bulk-offset-slider-container-${charId}`,
                            `bulk-offset-slider-thumb-${charId}`,
                            (pos) => {
                                const position = Math.round(pos);
                                document.getElementById(
                                    `bulk-offset-preview-${charId}`,
                                ).style.objectPosition = `center ${position}%`;
                                document.getElementById(
                                    `bulk-offset-text-${charId}`,
                                ).innerText = `${position}%`;
                                tempOffsetMap.set(charId, position);
                            },
                        );
                    });
                }, 50);

                modal.classList.remove("hidden");
            };

            window.closeBulkOffsetEditor = () => {
                document
                    .getElementById("bulk-offset-editor-modal")
                    .classList.add("hidden");
            };

            window.saveBulkOffsets = async () => {
                const btn = document.getElementById("save-bulk-offsets-btn");
                const originalHTML = btn.innerHTML;
                btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Guardando...`;
                btn.disabled = true;

                const allCharLists = [
                    ...window.charactersGlobal,
                    ...window.likedCharactersGlobal,
                    ...window.interestedCharactersGlobal,
                    ...window.dislikedCharactersGlobal,
                ];

                const updates = Array.from(tempOffsetMap.entries()).map(
                    ([id, offset]) => {
                        const char = allCharLists.find(
                            (c) => String(c.id) === id,
                        );
                        return {
                            id: id,
                            cover_offset_y: offset,
                            // Añadimos los campos NOT NULL para que el upsert no falle si intenta insertar
                            title: char ? char.title : "Unknown Character",
                            category: char ? char.category : "liked",
                        };
                    },
                );

                try {
                    const res = await fetch(
                        "/api/bulk-char-offset-update.json",
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ updates }),
                        },
                    );
                    if (!res.ok) {
                        const errorData = await res.json();
                        throw new Error(
                            errorData.error ||
                                "Falló la actualización masiva de offsets.",
                        );
                    }

                    const allCharLists = [
                        window.charactersGlobal,
                        window.likedCharactersGlobal,
                        window.interestedCharactersGlobal,
                        window.dislikedCharactersGlobal,
                    ];
                    updates.forEach((update) => {
                        for (const list of allCharLists) {
                            const char = list.find((c) => c.id == update.id);
                            if (char) {
                                char.cover_offset_y = update.cover_offset_y;
                                char.coverOffsetY = update.cover_offset_y;
                                break;
                            }
                        }
                    });

                    btn.innerHTML = `<i class="fa-solid fa-check"></i> ¡Guardado!`;
                    setTimeout(() => {
                        closeBulkOffsetEditor();
                        btn.innerHTML = originalHTML;
                        btn.disabled = false;
                    }, 1500);
                } catch (e) {
                    console.error(e);
                    alert("Error al guardar los offsets: " + e.message);
                    btn.innerHTML = originalHTML;
                    btn.disabled = false;
                }
            };

            // --- Bulk Edit Functions ---
            window.toggleBulkEditMode = (forceState) => {
                isBulkEditing =
                    typeof forceState === "boolean"
                        ? forceState
                        : !isBulkEditing;
                const btn = document.getElementById("bulk-edit-btn");
                const grid = document.getElementById("localGrid");

                if (isBulkEditing) {
                    btn.classList.add("bg-indigo-500/20", "text-indigo-300");
                    grid.classList.add("bulk-editing");
                } else {
                    btn.classList.remove("bg-indigo-500/20", "text-indigo-300");
                    grid.classList.remove("bulk-editing");
                    selectedItemIds.clear();
                }
                updateBulkActionBar();
                renderLocalLibrary(
                    document.getElementById("localFilter").value,
                );
            };

            window.toggleItemSelection = (itemId) => {
                if (!isBulkEditing) return;
                const card = document.querySelector(
                    `.asearch-card[data-id='${itemId}']`,
                );
                if (selectedItemIds.has(itemId)) {
                    selectedItemIds.delete(itemId);
                    card?.classList.remove("selected");
                } else {
                    selectedItemIds.add(itemId);
                    card?.classList.add("selected");
                }
                updateBulkActionBar();
            };

            function updateBulkActionBar() {
                const bar = document.getElementById("bulk-action-bar");
                const countEl = document.getElementById("bulk-count");
                if (isBulkEditing && selectedItemIds.size > 0) {
                    bar.classList.remove("hidden");
                    countEl.textContent = `${selectedItemIds.size} seleccionados`;
                } else {
                    bar.classList.add("hidden");
                }
            }

            window.openBulkStatusChanger = () => {
                document
                    .getElementById("bulk-main-view")
                    .classList.add("hidden");
                document
                    .getElementById("bulk-status-view")
                    .classList.remove("hidden");
            };

            window.closeBulkStatusChanger = () => {
                document
                    .getElementById("bulk-main-view")
                    .classList.remove("hidden");
                document
                    .getElementById("bulk-status-view")
                    .classList.add("hidden");
            };

            window.applyBulkStatusChange = async (newStatus) => {
                const statusView = document.getElementById("bulk-status-view");
                const originalStatusHTML = statusView.innerHTML;

                statusView.innerHTML = `<div class="flex items-center gap-2 px-4 py-2"><i class="fa-solid fa-circle-notch fa-spin text-white"></i><span class="text-xs text-gray-400">Actualizando...</span></div>`;

                const payload = {
                    ids: Array.from(selectedItemIds),
                    updates: { status: newStatus },
                };

                try {
                    const res = await fetch("/api/bulk-update.json", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(payload),
                    });
                    if (res.ok) {
                        alert(
                            `${payload.ids.length} obras actualizadas a "${newStatus}". Recargando...`,
                        );
                        window.location.reload();
                    } else {
                        throw new Error("Bulk update failed");
                    }
                } catch (e) {
                    console.error(e);
                    alert("Error al actualizar las obras.");
                    statusView.innerHTML = originalStatusHTML; // Restore on error
                }
            };

            // --- 2. DEFINIR LA FUNCIÓN PARA ABRIR EL EDITOR DE PERSONAJES ---
            window.openCharEditor = (item) => {
                // Guardamos el personaje actual para poder usarlo al dar a "Guardar"
                currentSelection = item;

                // Obtenemos los elementos del modal (asegúrate de que los IDs coincidan con tu HTML)
                const modal = document.getElementById("charEditor");
                const img = document.getElementById("charCover");
                const nameInput = document.getElementById("charNameInput");
                const sourceDisplayContainer =
                    document.getElementById("charSourceDisplay");
                const sourceDisplayText = document.getElementById(
                    "charSourceDisplayText",
                );

                if (
                    modal &&
                    img &&
                    nameInput &&
                    sourceDisplayContainer &&
                    sourceDisplayText
                ) {
                    img.src = item.cover;
                    nameInput.value = item.title;

                    const sourceId = item.source_id || item.sourceId;
                    if (sourceId) {
                        const sourceWork = window.localLibrary.find(
                            (w) => w.id === sourceId,
                        );
                        sourceDisplayText.innerHTML = `<span class="text-white">${sourceWork ? sourceWork.title : "Obra no encontrada"}</span>`;
                        sourceDisplayContainer.title = sourceWork
                            ? sourceWork.title
                            : "Obra no encontrada";
                    } else {
                        sourceDisplayText.innerHTML = `<span class="text-gray-500 italic">Ninguna seleccionada</span>`;
                        sourceDisplayContainer.title =
                            "Seleccionar obra de origen";
                    }

                    document.getElementById(
                        "charEditorPreviewTitle",
                    ).innerText = item.title;

                    const charOffsetY =
                        item.cover_offset_y ?? item.coverOffsetY ?? 50;
                    document.getElementById("charCoverOffsetYRange").value =
                        charOffsetY;
                    document.getElementById("charEditorPreviewCover").src =
                        item.cover;
                    document.getElementById(
                        "charEditorPreviewCover",
                    ).style.objectPosition = `center ${charOffsetY}%`;
                    document.getElementById("charCoverOffsetText").innerText =
                        `${charOffsetY}%`;
                    setSliderPosition("char-custom-slider-thumb", charOffsetY);

                    currentCharPickYear = new Date().getFullYear();
                    document.getElementById("charPickYearDisplay").innerText =
                        currentCharPickYear;
                    renderCharMonthTags();

                    // Mostramos el modal
                    modal.classList.remove("hidden");
                }
                initCustomSlider(
                    "char-custom-slider-container",
                    "char-custom-slider-thumb",
                    updateCharCoverOffset,
                );
            };

            // Función para cerrar el editor de personajes
            window.closeCharEditor = () => {
                document.getElementById("charEditor").classList.add("hidden");
            };

            function getDisplayTitle(item) {
                if (!item || !item.title) return "";
                // Para mangas, elimina el sufijo '-M' solo para mostrarlo en la UI
                if (item.type === "manga" && item.title.endsWith(" -M")) {
                    return item.title.slice(0, -3);
                }
                return item.title;
            }

            // --- Lógica para el selector de obras ---
            window.openWorkPicker = () => {
                renderWorkPickerGrid();
                document
                    .getElementById("work-picker-modal")
                    .classList.remove("hidden");
                document.getElementById("workPickerFilter").value = "";
                document.getElementById("workPickerFilter").focus();
            };

            window.closeWorkPicker = () => {
                document
                    .getElementById("work-picker-modal")
                    .classList.add("hidden");
            };

            function renderWorkPickerGrid(filter = "") {
                // Re-create the saga order map every time to reflect current saga order
                const sagaOrderMap = new Map();
                const sortedSagaNamesForMap = Object.keys(
                    window.sagas || {},
                ).sort();
                sortedSagaNamesForMap.forEach((sagaName, sagaIndex) => {
                    (window.sagas[sagaName] || []).forEach(
                        (title, gameIndex) => {
                            sagaOrderMap.set(title, {
                                sagaName,
                                sagaIndex,
                                gameIndex,
                            });
                        },
                    );
                });

                const grid = document.getElementById("work-picker-grid");
                const filteredLibrary = window.localLibrary
                    .filter((item) =>
                        item.title.toLowerCase().includes(filter.toLowerCase()),
                    )
                    .sort((a, b) => {
                        const sagaA = sagaOrderMap.get(a.title);
                        const sagaB = sagaOrderMap.get(b.title);

                        // Si ambos están en sagas
                        if (sagaA && sagaB) {
                            // Si están en la misma saga, ordenar por índice de juego
                            if (sagaA.sagaIndex === sagaB.sagaIndex) {
                                return sagaA.gameIndex - sagaB.gameIndex;
                            }
                            // Si están en sagas diferentes, ordenar por índice de saga
                            return sagaA.sagaIndex - sagaB.sagaIndex;
                        }

                        // Priorizar obras que están en sagas
                        if (sagaA && !sagaB) return -1;
                        if (!sagaA && sagaB) return 1;

                        // Si ninguno está en una saga, ordenar alfabéticamente
                        return a.title.localeCompare(b.title);
                    });

                grid.innerHTML = filteredLibrary
                    .map((item) => {
                        return `
                        <div onclick="selectWorkForChar('${item.id}')" class="asearch-card" draggable="false">
                            <img src="${item.cover}" class="obj-center" loading="lazy" draggable="false">
                            ${item.year ? `<div class="fixed-badge">${item.year}</div>` : ""}
                            <div class="asearch-info">
                                <h4 class="asearch-title">${item.title}</h4>
                            </div>
                        </div>
                    `;
                    })
                    .join("");
            }

            window.selectWorkForChar = (workId) => {
                // Handle bulk source picking
                if (isBulkSourcePicking) {
                    applyBulkSourceChange(workId);
                    return;
                }

                const work = window.localLibrary.find(
                    (item) => item.id === workId,
                );
                if (work && currentSelection) {
                    currentSelection.sourceId = work.id;

                    const displayContainer =
                        document.getElementById("charSourceDisplay");
                    const displayText = document.getElementById(
                        "charSourceDisplayText",
                    );
                    displayText.innerHTML = `<span class="text-white">${work.title}</span>`;
                    displayContainer.title = work.title;

                    closeWorkPicker();
                }
            };

            /**
             * Obtiene el año de una obra, buscando en `item.year` (para datos locales)
             * o en `item.startDate.year` (para datos de API de búsqueda).
             * @param {object} item - El objeto de la obra.
             * @returns {number|null} El año o null si no se encuentra.
             */
            function getWorkYear(item) {
                if (item.year) return item.year;
                if (item.startDate && item.startDate.year)
                    return item.startDate.year;
                return null;
            }

            function renderCard(item, actionName, isChar = false) {
                const fullId = isChar ? item.id : `${item.type}/${item.id}`;
                const isWorkBulkSelected =
                    !isChar && isBulkEditing && selectedItemIds.has(fullId);
                const isCharBulkSelected =
                    isChar && isCharBulkEditing && selectedCharIds.has(item.id);
                const isSelected = isWorkBulkSelected || isCharBulkSelected;

                let isFav;
                // Para mangas, la comprobación de favorito debe considerar el posible sufijo '-M'
                if (item.type === "manga") {
                    isFav =
                        window.favoritesTitles.includes(item.title) ||
                        window.favoritesTitles.includes(`${item.title} -M`);
                } else {
                    isFav = window.favoritesTitles.includes(item.title);
                }

                // encodeURIComponent doesn't escape single quotes, which breaks the onclick attribute.
                // We need to manually encode it for it to be a valid JS string inside the attribute.
                const safeItem = encodeURIComponent(
                    JSON.stringify(item),
                ).replace(/'/g, "%27");

                const displayTitle = getDisplayTitle(item);

                // Si es personaje, no mostramos estrellas
                const starRating =
                    !isChar && window.calculateRating
                        ? window.calculateRating(item.score || 0)
                        : 0;

                let sourceTitle = "";
                if (isChar) {
                    const sourceId = item.source_id || item.sourceId;
                    if (sourceId) {
                        const sourceWork = window.localLibrary.find(
                            (w) => w.id === sourceId,
                        );
                        if (sourceWork) sourceTitle = sourceWork.title;
                    } else if (item.source) {
                        // Backwards compatibility
                        // Backwards compatibility
                        sourceTitle = item.source;
                    }
                }

                let onclickAction = `handleCardClick('${actionName}', '${safeItem}')`;
                if (isBulkEditing && !isChar) {
                    onclickAction = `toggleItemSelection('${fullId}')`;
                } else if (isCharBulkEditing && isChar) {
                    onclickAction = `toggleCharItemSelection('${item.id}')`;
                }

                const showBulkCheckbox =
                    (isBulkEditing && !isChar) || (isCharBulkEditing && isChar);

                const year = getWorkYear(item);
                const itemType = (item.type || item.format || "").toLowerCase();
                const isManga = itemType === "manga";

                const isMusic = itemType === "music";

                return `
    <div
        data-id="${fullId}"
        data-title="${item.title}"
        onclick="${onclickAction}"
        class="asearch-card ${isSelected ? "selected" : ""}"
        draggable="false"
    >
        ${showBulkCheckbox ? `<div class="bulk-checkbox"><i class="fa-solid fa-check"></i></div>` : ""}
        <img src="${item.cover}" class="${isChar ? "obj-top" : "obj-center"}" loading="lazy" draggable="false" />
        ${!isChar && year ? `<div class="fixed-badge">${year}</div>` : ""}
        ${!isChar && isManga && actionName === "openEditorSearch" ? `<div class="fixed-badge" style="top: 30px; background: rgba(239, 68, 68, 0.6); font-size: 8px;">MANGA</div>` : ""}
        ${!isChar && isFav ? `<div class="heart-badge"><i class="fa-solid fa-heart"></i></div>` : ""}
        <div class="asearch-info">
            <h4 class="asearch-title">${displayTitle}</h4>
            ${isMusic && item.artist ? `<p class="text-[10px] text-gray-400 -mt-1 mb-1">${item.artist}</p>` : ""}
            ${!isChar && starRating > 0 ? `<div class="asearch-rating"><span>${starRating}</span><i class="fa-solid fa-star"></i></div>` : ""}
            ${
                isChar && sourceTitle
                    ? `<p class="text-[9px] text-pink-400 font-bold uppercase mt-2">${sourceTitle}</p>`
                    : ""
            }
        </div>
    </div>`;
            }

            window.setLocalSort = (sort, btn) => {
                localCurrentSort = sort;
                const orderBtn = document.getElementById("localOrderBtn");
                orderBtn.style.display = sort === "saga" ? "none" : "flex";
                if (sort === "saga") localIsAscending = false;
                document.querySelectorAll(".sort-btn-local").forEach((b) => {
                    b.classList.remove("bg-white/5", "text-white");
                    b.classList.add("text-gray-500");
                });
                btn.classList.remove("text-gray-500");
                btn.classList.add("bg-white/5", "text-white");
                renderLocalLibrary(
                    document.getElementById("localFilter").value,
                );
            };

            window.toggleLocalOrder = () => {
                if (localCurrentSort === "saga") return;
                localIsAscending = !localIsAscending;
                const btn = document.getElementById("localOrderBtn");
                btn.innerHTML = localIsAscending
                    ? '<i class="fa-solid fa-arrow-up-wide-short text-xs"></i>'
                    : '<i class="fa-solid fa-arrow-down-wide-short text-xs"></i>';
                renderLocalLibrary(
                    document.getElementById("localFilter").value,
                );
            };

            function renderLocalLibrary(filterText = "") {
                const filtered = window.localLibrary.filter((item) =>
                    item.title.toLowerCase().includes(filterText.toLowerCase()),
                );

                // FIX: Crear el mapa de sagas para la ordenación.
                // Esta variable no estaba definida, causando un error que impedía renderizar la biblioteca.
                const sagaOrderMap = new Map();
                const sortedSagaNamesForMap = Object.keys(
                    window.sagas || {},
                ).sort();
                sortedSagaNamesForMap.forEach((sagaName, sagaIndex) => {
                    (window.sagas[sagaName] || []).forEach(
                        (title, gameIndex) => {
                            sagaOrderMap.set(title, {
                                sagaName,
                                sagaIndex,
                                gameIndex,
                            });
                        },
                    );
                });

                filtered.sort((a, b) => {
                    if (localCurrentSort === "saga") {
                        const sagaA = sagaOrderMap.get(a.title);
                        const sagaB = sagaOrderMap.get(b.title);
                        const sortKeyA = sagaA ? sagaA.sagaName : a.title;
                        const sortKeyB = sagaB ? sagaB.sagaName : b.title;
                        if (sortKeyA !== sortKeyB) {
                            return sortKeyA.localeCompare(sortKeyB);
                        }
                        if (sagaA && sagaB) {
                            return sagaA.gameIndex - sagaB.gameIndex;
                        }
                        return 0;
                    }
                    let valA, valB;
                    if (localCurrentSort === "score") {
                        valA = Number(a.score || 0);
                        valB = Number(b.score || 0);
                    } else if (localCurrentSort === "year") {
                        valA = a.finishDate || "0";
                        valB = b.finishDate || "0";
                    } else {
                        // title
                        valA = a.title.toLowerCase();
                        valB = b.title.toLowerCase();
                    }
                    if (valA < valB) return localIsAscending ? -1 : 1;
                    if (valA > valB) return localIsAscending ? 1 : -1;
                    return 0;
                });

                document.getElementById("localGrid").innerHTML = filtered
                    .map((item) => renderCard(item, "openEditorLocal"))
                    .join("");
            }
            document
                .getElementById("localFilter")
                .addEventListener("input", (e) =>
                    renderLocalLibrary(e.target.value),
                );

            window.openEditorSearch = (item) => {
                const type = document.getElementById("mediaType").value;
                const typeToFind = type === "game" ? "games" : type;
                if (type === "music") {
                    openEditorMusic(item);
                    return;
                }
                const existing = window.localLibrary.find((l) => {
                    if (l.type !== typeToFind) return false;
                    // Para mangas, buscar con y sin el sufijo -M
                    if (typeToFind === "manga") {
                        // Normaliza ambos títulos eliminando el sufijo " -M" antes de comparar.
                        // Esto hace la búsqueda robusta sin importar si el título en la BD está "sucio" o "limpio".
                        const libTitle = l.title.endsWith(" -M")
                            ? l.title.slice(0, -3)
                            : l.title;
                        const searchTitle = item.title.endsWith(" -M")
                            ? item.title.slice(0, -3)
                            : item.title;
                        return libTitle === searchTitle;
                    }
                    return l.title === item.title;
                });
                const dataToFill = existing
                    ? existing
                    : {
                          ...item,
                          type:
                              type === "game"
                                  ? "games"
                                  : type === "manga"
                                    ? "manga"
                                    : "anime",
                      };
                fillEditor(dataToFill, type);
            };
            window.openEditorLocal = (item) => fillEditor(item, item.type);

            window.openEditorMusic = (item) => {
                const existing = window.localMusic.find(
                    (l) =>
                        l.title === item.title &&
                        (l.artist ? l.artist === item.artist : true),
                );
                const dataToFill = existing
                    ? existing
                    : {
                          ...item,
                          type: "music",
                          artist: item.artist || "Artista Desconocido",
                          album: item.album || "Álbum Desconocido",
                      };
                fillEditor(dataToFill, "music");
            };

            function fillEditor(data, type) {
                currentSelection = data;
                currentSelection.type = type; // Asegurarse de que el tipo está bien definido
                const displayTitle = getDisplayTitle(data);
                document.getElementById("editor").classList.remove("hidden");
                document.getElementById("editorTitle").innerText = displayTitle;
                document.getElementById("editorYear").innerText =
                    data.year || "----";
                document.getElementById("editorCover").src = data.cover;

                document.getElementById("privateNotes").value =
                    data.private_notes || data.privateNotes || "";

                // Saga Selector Logic
                const sagaContainer = document.getElementById("sagaContainer");
                const albumContainer =
                    document.getElementById("albumContainer");

                if (type === "music") {
                    sagaContainer.classList.add("hidden");
                    albumContainer.classList.remove("hidden");
                    document.getElementById("albumInput").value =
                        data.album || "";
                } else {
                    sagaContainer.classList.remove("hidden");
                    albumContainer.classList.add("hidden");

                    const sagaSelector =
                        document.getElementById("sagaSelector");
                    sagaSelector.innerHTML =
                        '<option value="">Ninguna</option>';

                    let currentSaga = "";
                    const workTitle = data.title.endsWith(" -M")
                        ? data.title.slice(0, -3)
                        : data.title;
                    for (const sagaName in window.sagas) {
                        const option = document.createElement("option");
                        option.value = sagaName;
                        option.textContent = sagaName;
                        sagaSelector.appendChild(option);
                        if (window.sagas[sagaName].includes(workTitle)) {
                            currentSaga = sagaName;
                        }
                    }
                    sagaSelector.value = currentSaga;
                }

                const status = data.status || "Jugando";
                document
                    .querySelectorAll('input[name="status"]')
                    .forEach((r) => {
                        r.checked = r.value === status;
                    });

                document.getElementById("startDate").value =
                    data.start_date || data.startDate || "";
                document.getElementById("finishDate").value =
                    data.finish_date || data.finishDate || "";

                // --- Lógica para el nuevo PREVIEW de la cover ---
                document.getElementById("editorPreviewCover").src = data.cover;
                const editorPreviewTitle =
                    document.getElementById("editorPreviewTitle");
                editorPreviewTitle.innerText =
                    type === "music"
                        ? `${data.artist || ""} - ${displayTitle}`
                        : displayTitle;
                const editorSubtitle =
                    document.getElementById("editorSubtitle");
                editorSubtitle.innerText = type === "music" ? data.album : "";
                editorSubtitle.style.display =
                    type === "music" ? "block" : "none";
                const offsetY = data.cover_offset_y ?? data.coverOffsetY ?? 50;
                document.getElementById("coverOffsetYRange").value = offsetY;
                document.getElementById(
                    "editorPreviewCover",
                ).style.objectPosition = `center ${offsetY}%`;
                document.getElementById("coverOffsetText").innerText =
                    `${offsetY}%`;
                setSliderPosition("custom-slider-thumb", offsetY);

                currentPickYear = new Date().getFullYear();

                document.getElementById("pickYearDisplay").innerText =
                    currentPickYear;

                updateStarsVisual(data.score || 0);

                if (type === "music") {
                    isFavorite = false; // La música no está en favoritos (por ahora)
                    document.getElementById("favBtn").style.display = "none";
                } else {
                    document.getElementById("favBtn").style.display = "flex";
                    let favTitleToCheck = data.title;
                    if (data.type === "manga") {
                        favTitleToCheck = `${data.title} -M`;
                    }
                    isFavorite = window.favoritesTitles.some((fav) => {
                        const favTitle =
                            typeof fav === "object" ? fav.title : fav;
                        return favTitle === favTitleToCheck;
                    });
                }
                updateFavBtn();
                renderMonthTags();
                checkScoreLock();

                initCustomSlider(
                    "custom-slider-container",
                    "custom-slider-thumb",
                    (pos) => {
                        const position = Math.round(pos);
                        document.getElementById(
                            "editorPreviewCover",
                        ).style.objectPosition = `center ${position}%`;
                        document.getElementById("coverOffsetText").innerText =
                            `${position}%`;
                        document.getElementById("coverOffsetYRange").value =
                            position;
                    },
                );
            }

            window.closeEditor = () =>
                document.getElementById("editor").classList.add("hidden");

            window.changePickYear = (delta) => {
                currentPickYear += delta;
                document.getElementById("pickYearDisplay").innerText =
                    currentPickYear;
                renderMonthTags();
            };

            window.toggleMonthPick = (month) => {
                const dateStr = `${currentPickYear}-${month}`;
                const exists = window.monthlyPicksGlobal.some(
                    (e) =>
                        e.month === dateStr &&
                        e.title === currentSelection.title,
                );

                if (exists) {
                    window.monthlyPicksGlobal =
                        window.monthlyPicksGlobal.filter(
                            (e) =>
                                !(
                                    e.month === dateStr &&
                                    e.title === currentSelection.title
                                ),
                        );
                } else {
                    window.monthlyPicksGlobal.push({
                        month: dateStr,
                        title: currentSelection.title,
                        cover: currentSelection.cover,
                    });
                    window.monthlyPicksGlobal.sort((a, b) =>
                        b.month.localeCompare(a.month),
                    );
                }
                renderMonthTags();
            };

            window.changeCharPickYear = (delta) => {
                currentCharPickYear += delta;
                document.getElementById("charPickYearDisplay").innerText =
                    currentCharPickYear;
                renderCharMonthTags();
            };

            window.toggleCharMonthPick = (month) => {
                const dateStr = `${currentCharPickYear}-${month}`;
                const exists = window.monthlyCharsGlobal.some(
                    (e) =>
                        e.month === dateStr &&
                        e.name === currentSelection.title,
                );

                if (exists) {
                    window.monthlyCharsGlobal =
                        window.monthlyCharsGlobal.filter(
                            (e) =>
                                !(
                                    e.month === dateStr &&
                                    e.name === currentSelection.title
                                ),
                        );
                } else {
                    window.monthlyCharsGlobal.push({
                        month: dateStr,
                        name: currentSelection.title,
                        cover: currentSelection.cover,
                    });
                    window.monthlyCharsGlobal.sort((a, b) =>
                        b.month.localeCompare(a.month),
                    );
                }
                renderCharMonthTags();
            };

            function renderCharMonthTags() {
                const container = document.getElementById(
                    "charMonthlyTagsContainer",
                );
                const tagsForCurrentWork = window.monthlyCharsGlobal.filter(
                    (entry) => entry.name === currentSelection.title,
                );
                container.innerHTML = tagsForCurrentWork
                    .map((tag) => `<div class="mini-tag">${tag.month}</div>`)
                    .join("");

                document
                    .querySelectorAll("#charEditor .month-btn-item")
                    .forEach((btn, index) => {
                        const month = (index + 1).toString().padStart(2, "0");
                        const dateStr = `${currentCharPickYear}-${month}`;

                        const isSelectedForThisWork = tagsForCurrentWork.some(
                            (tag) => tag.month === dateStr,
                        );

                        const isTakenByAnotherWork =
                            window.monthlyCharsGlobal.some(
                                (entry) =>
                                    entry.month === dateStr &&
                                    entry.name !== currentSelection.title,
                            );

                        btn.classList.remove("selected", "disabled");
                        btn.disabled = false;

                        if (isSelectedForThisWork) {
                            btn.classList.add("selected");
                        } else if (isTakenByAnotherWork) {
                            btn.classList.add("disabled");
                            btn.disabled = true;
                        }
                    });
            }

            function renderMonthTags() {
                const container = document.getElementById(
                    "monthlyTagsContainer",
                );
                const tagsForCurrentWork = window.monthlyPicksGlobal.filter(
                    (entry) => entry.title === currentSelection.title,
                );
                container.innerHTML = tagsForCurrentWork
                    .map((tag) => `<div class="mini-tag">${tag.month}</div>`)
                    .join("");

                document
                    .querySelectorAll(".month-btn-item")
                    .forEach((btn, index) => {
                        const month = (index + 1).toString().padStart(2, "0");
                        const dateStr = `${currentPickYear}-${month}`;

                        const isSelectedForThisWork = tagsForCurrentWork.some(
                            (tag) => tag.month === dateStr,
                        );

                        const isTakenByAnotherWork =
                            window.monthlyPicksGlobal.some(
                                (entry) =>
                                    entry.month === dateStr &&
                                    entry.title !== currentSelection.title,
                            );

                        btn.classList.remove("selected", "disabled");
                        btn.disabled = false;

                        if (isSelectedForThisWork) {
                            btn.classList.add("selected");
                        } else if (isTakenByAnotherWork) {
                            btn.classList.add("disabled");
                            btn.disabled = true;
                        }
                    });
            }

            // --- GUARDAR ---
            // --- DENTRO DEL SCRIPT IS:INLINE DE admin.astro ---

            document
                .getElementById("saveMediaBtn")
                .addEventListener("click", async () => {
                    const btn = document.getElementById("saveMediaBtn");
                    const originalText = btn.innerText;
                    btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Guardando...`;
                    btn.disabled = true;

                    // 1. Recoger valores del DOM
                    const status = document.querySelector(
                        'input[name="status"]:checked',
                    ).value;
                    const scoreVal =
                        document.getElementById("scoreRange").value;
                    const startDate =
                        document.getElementById("startDate").value;
                    const finishDate =
                        document.getElementById("finishDate").value;
                    const privateNotes =
                        document.getElementById("privateNotes").value;
                    const coverOffsetY =
                        document.getElementById("coverOffsetYRange").value;

                    // Handle Saga update
                    const selectedSaga =
                        document.getElementById("sagaSelector").value;
                    let oldSaga = "";
                    for (const sagaName in window.sagas) {
                        if (
                            window.sagas[sagaName].includes(
                                currentSelection.title,
                            )
                        ) {
                            oldSaga = sagaName;
                            break;
                        }
                    }

                    if (oldSaga !== selectedSaga) {
                        if (oldSaga && window.sagas[oldSaga]) {
                            window.sagas[oldSaga] = window.sagas[
                                oldSaga
                            ].filter((t) => t !== currentSelection.title);
                        }
                        if (selectedSaga && window.sagas[selectedSaga]) {
                            window.sagas[selectedSaga].push(
                                currentSelection.title,
                            );
                        }
                    }

                    // 2. Preparar los payloads
                    const fileData = {
                        title: currentSelection.title,
                        cover: currentSelection.cover,
                        year: currentSelection.year,
                        type: currentSelection.type,
                        artist: currentSelection.artist, // Para música
                        status: status,
                        score: status === "Completado" ? Number(scoreVal) : 0,
                        startDate: startDate,
                        finishDate: finishDate,
                        coverOffsetY: Number(coverOffsetY),
                        privateNotes: privateNotes,
                    };

                    if (fileData.type === "music") {
                        fileData.album =
                            document.getElementById("albumInput").value;
                    }

                    if (fileData.type !== "music") {
                        const isNewItem =
                            typeof currentSelection.id === "number";
                        if (isNewItem && fileData.type === "manga") {
                            fileData.title = `${fileData.title} -M`;
                        }

                        // This is the title that will be in the favorites list if added/removed.
                        // It MUST have the -M suffix for manga.
                        let favTitleToManage;
                        if (fileData.type === "manga") {
                            favTitleToManage = fileData.title.endsWith(" -M")
                                ? fileData.title
                                : `${fileData.title} -M`;
                        } else {
                            favTitleToManage = fileData.title;
                        }

                        const isAlreadyInFavs = window.favoritesTitles.some(
                            (fav) => {
                                const existingFavTitle =
                                    typeof fav === "object" ? fav.title : fav;
                                return existingFavTitle === favTitleToManage;
                            },
                        );

                        if (isFavorite && !isAlreadyInFavs) {
                            window.favoritesTitles.push({
                                title: favTitleToManage,
                                is_saga: false,
                            });
                        } else if (!isFavorite && isAlreadyInFavs) {
                            window.favoritesTitles =
                                window.favoritesTitles.filter((fav) => {
                                    const existingFavTitle =
                                        typeof fav === "object"
                                            ? fav.title
                                            : fav;
                                    return (
                                        existingFavTitle !== favTitleToManage
                                    );
                                });
                        }
                    }

                    const combinedPayload = {
                        fileData: fileData,
                        dbData: {
                            favorites: window.favoritesTitles,
                            monthlyPicks: window.monthlyPicksGlobal,
                            sagas: window.sagas,
                        },
                    };

                    try {
                        const res = await fetch("/api/save.json", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(combinedPayload),
                        });

                        if (res.ok) {
                            // Éxito: recargar para que Astro reconozca los nuevos archivos .json
                            btn.innerHTML = `<i class="fa-solid fa-check"></i> ¡Guardado! Recargando...`;
                            // Pequeña espera y recarga con cache-busting para asegurar que se obtienen los datos más recientes.
                            setTimeout(() => {
                                // Añadimos un timestamp para evitar que el navegador sirva una versión cacheada de la página.
                                window.location.href =
                                    window.location.pathname +
                                    "?t=" +
                                    new Date().getTime();
                            }, 500);
                        } else {
                            throw new Error(
                                "Fallo en la respuesta del servidor",
                            );
                        }
                    } catch (e) {
                        console.error("Error al guardar:", e);
                        alert("Error al guardar los datos. Revisa la consola.");
                        btn.innerText = originalText;
                        btn.disabled = false;
                    }
                });

            function updateStarsVisual(value) {
                document.getElementById("scoreRange").value = value;
                const visualScore = value / 2;
                document.getElementById("scoreText").innerText = (
                    value / 2
                ).toFixed(value % 2 === 0 ? 0 : 1);
                let html = "";
                for (let i = 1; i <= 5; i++) {
                    let iconClass = "fa-regular fa-star";
                    let colorClass = "text-gray-600"; // Color visible para estrellas vacías
                    if (visualScore >= i) {
                        iconClass = "fa-solid fa-star";
                        colorClass = "text-white";
                    } else if (visualScore >= i - 0.5) {
                        iconClass = "fa-solid fa-star-half-stroke";
                        colorClass = "text-white";
                    }
                    html += `<span class="relative inline-block px-0.5 group/star"><i class="${iconClass} ${colorClass} group-hover/star:text-white transition-colors"></i><div class="absolute left-0 top-0 bottom-0 w-1/2 z-10" onclick="setScore(${i * 2 - 1})"></div><div class="absolute right-0 top-0 bottom-0 w-1/2 z-10" onclick="setScore(${i * 2})"></div></span>`;
                }
                document.getElementById("starsVisual").innerHTML = html;
            }

            window.setScore = (val) => {
                if (!document.getElementById("scoreRange").disabled)
                    updateStarsVisual(val);
            };

            window.checkScoreLock = () => {
                const status = document.querySelector(
                    'input[name="status"]:checked',
                ).value;
                const range = document.getElementById("scoreRange");
                const container = document.getElementById("scoreContainer");
                if (status === "Completado") {
                    range.disabled = false;
                    container.style.opacity = "1";
                    container.style.pointerEvents = "auto";
                } else {
                    range.disabled = true;
                    container.style.opacity = "0.3";
                    container.style.pointerEvents = "none";
                    updateStarsVisual(0);
                }
            };

            window.toggleFav = () => {
                isFavorite = !isFavorite;
                updateFavBtn();
            };

            function updateFavBtn() {
                const btn = document.getElementById("favBtn");
                if (isFavorite) {
                    btn.innerHTML = `<i class="fa-solid fa-heart text-red-500 drop-shadow-[0_0_10px_rgba(239,68,68,0.6)]"></i>`;
                    btn.classList.add("scale-110");
                } else {
                    btn.innerHTML = `<i class="fa-regular fa-heart"></i>`;
                    btn.classList.remove("scale-110");
                }
            }

            document
                .getElementById("searchForm")
                .addEventListener("submit", async (e) => {
                    e.preventDefault();
                    const q = document.getElementById("searchInput").value;
                    const t = document.getElementById("mediaType").value;
                    if (!q) return;
                    document.getElementById("searchResults").innerHTML = "...";
                    try {
                        const res = await fetch(
                            `/api/search.json?q=${encodeURIComponent(q)}&type=${t}`,
                        );
                        const data = await res.json();
                        const keywordsToFilter = [
                            "digital deluxe",
                            "collection",
                            "hd edition",
                        ];
                        const filteredData = data.filter((item) => {
                            const lowerCaseTitle = item.title.toLowerCase();
                            return !keywordsToFilter.some((keyword) =>
                                lowerCaseTitle.includes(keyword),
                            );
                        });
                        document.getElementById("searchResults").innerHTML =
                            filteredData
                                .map((i) => renderCard(i, "openEditorSearch"))
                                .join("");
                    } catch (e) {
                        console.error("Error en búsqueda:", e);
                        document.getElementById("searchResults").innerHTML =
                            `<p class="col-span-full text-red-400">Error al buscar</p>`;
                    }
                });

            // Búsqueda de música
            document
                .getElementById("musicSearchForm")
                .addEventListener("submit", async (e) => {
                    e.preventDefault();
                    const q = document.getElementById("musicSearchInput").value;
                    if (!q) return;
                    document.getElementById("musicSearchResults").innerHTML =
                        `<p class="col-span-full text-center text-white/50 animate-pulse">Buscando...</p>`;
                    try {
                        const res = await fetch(
                            `/api/search.json?q=${encodeURIComponent(q)}&type=music`,
                        );
                        const data = await res.json();
                        // La API ahora devuelve los datos en el formato correcto: { title, artist, cover, year, type: 'music' }

                        document.getElementById(
                            "musicSearchResults",
                        ).innerHTML =
                            data.length > 0
                                ? data
                                      .map((i) =>
                                          renderCard(i, "openEditorMusic"),
                                      )
                                      .join("")
                                : `<p class="col-span-full text-center text-white/20">No se encontraron resultados.</p>`;
                    } catch (e) {
                        console.error("Error en búsqueda de música:", e);
                        document.getElementById(
                            "musicSearchResults",
                        ).innerHTML =
                            `<p class="col-span-full text-red-400">Error al buscar música</p>`;
                    }
                });

            // --- Lógica para guardar la posición de scroll ---
            let activeScrollListeners = [];

            function saveScrollPosition(event) {
                const el = event.target;
                // Usamos un timeout para no sobrecargar localStorage en cada pixel de scroll
                if (el.scrollTimeout) clearTimeout(el.scrollTimeout);
                el.scrollTimeout = setTimeout(() => {
                    if (el.id) {
                        localStorage.setItem(
                            `scrollPos-${el.id}`,
                            el.scrollTop,
                        );
                    }
                }, 100);
            }

            window.switchMode = (mode) => {
                // 1. Limpiar listeners de scroll del panel anterior
                activeScrollListeners.forEach(({ el, handler }) =>
                    el.removeEventListener("scroll", handler),
                );
                activeScrollListeners = [];

                // 2. Ocultar todos los paneles y desactivar botones de navegación
                document
                    .querySelectorAll(".panel")
                    .forEach((p) => p.classList.add("hidden"));
                document
                    .querySelectorAll(".nav-btn")
                    .forEach((b) => b.classList.remove("active"));

                // 3. Mostrar el panel activo
                const panel = document.getElementById(`${mode}-panel`);
                if (!panel) return; // Parar si el panel no existe
                panel.classList.remove("hidden");

                // 4. Activar el botón de navegación correspondiente
                const btn = document.querySelector(
                    `button[onclick="switchMode('${mode}')"]`,
                );
                if (btn) btn.classList.add("active");

                // 5. Guardar la pestaña activa en localStorage para la próxima recarga
                localStorage.setItem("activeTab", mode);

                // 6. Renderizar el contenido específico del panel
                if (mode === "library") renderLocalLibrary();
                if (mode === "favorites") {
                    const worksView = document.getElementById("fav-works-view");
                    if (!worksView.classList.contains("hidden")) {
                        renderFavWorksSortable();
                    } else {
                        setupCharacterFavoritesView();
                    }
                }
                if (mode === "characters") {
                    document.getElementById("charResults").innerHTML = "";
                }
                if (mode === "my-characters") renderMyCharacters();
                if (mode === "sagas") renderSagasPanel();
                if (mode === "my-music") renderLocalMusic();
                if (mode === "music-search") {
                    document.getElementById("musicSearchResults").innerHTML =
                        "";
                }
                if (mode === "images") {
                    renderImageManager(); // Renderiza el contenido inicial
                    switchImageManagerView("works"); // Activa la vista de obras por defecto
                }

                // 7. Restaurar posición de scroll y añadir nuevos listeners
                setTimeout(() => {
                    panel
                        .querySelectorAll(".custom-scrollbar")
                        .forEach((el, index) => {
                            if (!el.id) el.id = `scroll-${mode}-${index}`;
                            const savedScroll = localStorage.getItem(
                                `scrollPos-${el.id}`,
                            );
                            if (savedScroll)
                                el.scrollTop = parseInt(savedScroll, 10);
                            el.addEventListener("scroll", saveScrollPosition);
                            activeScrollListeners.push({
                                el: el,
                                handler: saveScrollPosition,
                            });
                        });
                }, 50); // Pequeño delay para asegurar que el contenido se ha renderizado
            };

            function renderLocalMusic(filterText = "") {
                const grid = document.getElementById("localMusicGrid");
                if (!grid) return;

                const lowerFilter = filterText.toLowerCase();
                const filtered = window.localMusic.filter(
                    (item) =>
                        item.title.toLowerCase().includes(lowerFilter) ||
                        (item.artist &&
                            item.artist.toLowerCase().includes(lowerFilter)),
                );

                filtered.sort(
                    (a, b) =>
                        (a.artist || "").localeCompare(b.artist || "") ||
                        a.title.localeCompare(b.title),
                );

                grid.innerHTML =
                    filtered.length > 0
                        ? filtered
                              .map((item) =>
                                  renderCard(item, "openEditorMusic"),
                              )
                              .join("")
                        : `<p class="col-span-full text-center text-white/20 text-sm py-10">No tienes música en tu colección.</p>`;
            }
            document
                .getElementById("localMusicFilter")
                .addEventListener("input", (e) =>
                    renderLocalMusic(e.target.value),
                );

            function renderImageManager() {
                const worksGrid = document.getElementById(
                    "image-manager-works-grid",
                );
                const charsGrid = document.getElementById(
                    "image-manager-chars-grid",
                );

                if (!worksGrid || !charsGrid) return;

                const sortedWorks = [...window.localLibrary].sort((a, b) =>
                    a.title.localeCompare(b.title),
                );
                worksGrid.innerHTML = sortedWorks
                    .map((item) => renderImageManagerCard(item, "work"))
                    .join("");

                const allChars = [
                    ...window.charactersGlobal,
                    ...window.likedCharactersGlobal,
                    ...window.interestedCharactersGlobal,
                    ...window.dislikedCharactersGlobal,
                ].sort((a, b) => a.title.localeCompare(b.title));

                charsGrid.innerHTML = allChars
                    .map((item) => renderImageManagerCard(item, "char"))
                    .join("");
            }

            function renderImageManagerCard(item, type) {
                const itemId = type === "work" ? item.id : String(item.id);

                return `
                    <div class="relative aspect-[2/3] bg-zinc-900 rounded-lg overflow-hidden group border border-white/5">
                        <img src="${item.cover}" loading="lazy" class="w-full h-full object-cover object-center">
                        <div class="absolute bottom-0 inset-x-0 p-2 bg-gradient-to-t from-black/80 to-transparent">
                            <p class="text-[10px] text-white/80 truncate font-bold" title="${item.title}">${item.title}</p>
                        </div>
                        <button onclick="changeItemCover('${itemId}', '${type}', this)" class="absolute top-1.5 right-1.5 w-7 h-7 bg-indigo-500/50 text-indigo-200 rounded-full flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity border border-indigo-500/50 hover:bg-indigo-500/80" title="Cambiar imagen">
                            <i class="fa-solid fa-pen-to-square text-xs"></i>
                        </button>
                    </div>
                `;
            }

            // --- NUEVA LÓGICA PARA SUBIR IMÁGENES ---
            let currentItemForCoverChange = null;

            window.closeImageUploader = () => {
                document
                    .getElementById("image-uploader-modal")
                    .classList.add("hidden");
                document.getElementById("image-uploader-status").innerHTML = "";
                currentItemForCoverChange = null;
            };

            window.changeItemCover = (itemId, itemType, btn) => {
                currentItemForCoverChange = { itemId, itemType, btn };
                document
                    .getElementById("image-uploader-modal")
                    .classList.remove("hidden");
            };

            async function handleImageUpload(file) {
                if (!file || !file.type.startsWith("image/")) {
                    alert("Por favor, selecciona un archivo de imagen válido.");
                    return;
                }
                if (!currentItemForCoverChange) return;

                const { itemId, itemType, btn } = currentItemForCoverChange;
                const statusEl = document.getElementById(
                    "image-uploader-status",
                );

                statusEl.innerHTML = `<div class="flex items-center justify-center gap-2 text-indigo-400"><i class="fa-solid fa-circle-notch fa-spin"></i> Subiendo imagen...</div>`;
                if (btn) {
                    btn.innerHTML =
                        '<i class="fa-solid fa-circle-notch fa-spin"></i>';
                    btn.disabled = true;
                }

                const tableName = itemType === "work" ? "works" : "characters";

                // Lógica robusta para obtener la extensión del archivo
                let fileExt = "png"; // Extensión por defecto
                if (file.name) {
                    // Si es un objeto File con nombre
                    const nameParts = file.name.split(".");
                    if (nameParts.length > 1) {
                        fileExt = nameParts.pop();
                    }
                } else if (file.type && file.type.startsWith("image/")) {
                    // Si es un Blob del portapapeles
                    fileExt = file.type.substring(6); // 'image/png' -> 'png'
                }

                const filePath = `${itemType}/${itemId}-${Date.now()}.${fileExt.toLowerCase()}`;

                try {
                    const { error: uploadError } = await supabase.storage
                        .from("covers")
                        .upload(filePath, file);

                    if (uploadError)
                        throw new Error(
                            `Error de Supabase Storage: ${uploadError.message}`,
                        );

                    const { data: urlData } = supabase.storage
                        .from("covers")
                        .getPublicUrl(filePath);

                    const newUrl = urlData.publicUrl;

                    const { error: dbError } = await supabase
                        .from(tableName)
                        .update({ cover: newUrl })
                        .eq("id", itemId);

                    if (dbError)
                        throw new Error(
                            `Error de base de datos: ${dbError.message}`,
                        );

                    if (itemType === "work") {
                        const work = window.localLibrary.find(
                            (w) => w.id === itemId,
                        );
                        if (work) work.cover = newUrl;
                    } else {
                        const allCharLists = [
                            window.charactersGlobal,
                            window.likedCharactersGlobal,
                            window.interestedCharactersGlobal,
                            window.dislikedCharactersGlobal,
                        ];
                        for (const list of allCharLists) {
                            const char = list.find(
                                (c) => String(c.id) === String(itemId),
                            );
                            if (char) {
                                char.cover = newUrl;
                                break;
                            }
                        }
                    }

                    const cardImg = btn.closest(".group").querySelector("img");
                    if (cardImg) cardImg.src = newUrl;

                    statusEl.innerHTML = `<div class="flex items-center justify-center gap-2 text-green-400"><i class="fa-solid fa-check"></i> ¡Imagen actualizada!</div>`;

                    if (btn)
                        btn.innerHTML = '<i class="fa-solid fa-check"></i>';

                    setTimeout(() => {
                        closeImageUploader();
                        if (btn) {
                            btn.innerHTML =
                                '<i class="fa-solid fa-pen-to-square text-xs"></i>';
                            btn.disabled = false;
                        }
                    }, 1500);
                } catch (e) {
                    console.error("Error al cambiar la imagen:", e);
                    statusEl.innerHTML = `<div class="text-red-400">Error: ${e.message}</div>`;
                    if (btn) {
                        btn.innerHTML =
                            '<i class="fa-solid fa-pen-to-square text-xs"></i>';
                        btn.disabled = false;
                    }
                }
            }

            function setupImageUploader() {
                const modal = document.getElementById("image-uploader-modal");
                const dropzone = document.getElementById(
                    "image-uploader-dropzone",
                );
                const fileInput = document.getElementById(
                    "image-uploader-input",
                );

                if (!modal || !dropzone || !fileInput) return;

                const preventDefaults = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                };
                ["dragenter", "dragover", "dragleave", "drop"].forEach(
                    (eventName) => {
                        dropzone.addEventListener(
                            eventName,
                            preventDefaults,
                            false,
                        );
                    },
                );

                dropzone.addEventListener("dragenter", () =>
                    dropzone.classList.add("border-indigo-500"),
                );
                dropzone.addEventListener("dragleave", () =>
                    dropzone.classList.remove("border-indigo-500"),
                );

                dropzone.addEventListener("drop", (e) => {
                    dropzone.classList.remove("border-indigo-500");
                    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                        handleImageUpload(e.dataTransfer.files[0]);
                    }
                });

                fileInput.addEventListener("change", (e) => {
                    if (e.target.files && e.target.files[0]) {
                        handleImageUpload(e.target.files[0]);
                    }
                });

                document.body.addEventListener("paste", async (e) => {
                    if (modal.classList.contains("hidden")) return; // Only paste when modal is open
                    e.preventDefault();
                    try {
                        const items = e.clipboardData?.items || [];
                        for (const item of items) {
                            if (item.type.indexOf("image") !== -1) {
                                const blob = item.getAsFile();
                                if (blob) {
                                    handleImageUpload(blob);
                                    return;
                                }
                            }
                        }
                        document.getElementById(
                            "image-uploader-status",
                        ).innerHTML =
                            `<div class="text-red-400">No se encontró una imagen en el portapapeles.</div>`;
                    } catch (err) {
                        console.error("Error al leer el portapapeles: ", err);
                        document.getElementById(
                            "image-uploader-status",
                        ).innerHTML =
                            `<div class="text-red-400">No se pudo leer el portapapeles.</div>`;
                    }
                });
            }

            window.switchImageManagerView = (type) => {
                const worksView = document.getElementById(
                    "image-manager-works-view",
                );
                const charsView = document.getElementById(
                    "image-manager-chars-view",
                );
                const btnWorks = document.getElementById("btn-img-mgr-works");
                const btnChars = document.getElementById("btn-img-mgr-chars");
                const bg = document.getElementById("img-mgr-tab-bg");

                if (type === "works") {
                    worksView.classList.remove("hidden");
                    charsView.classList.add("hidden");
                    bg.style.transform = "translateX(0)";
                    btnWorks.classList.remove("opacity-50");
                    btnChars.classList.add("opacity-50");
                } else {
                    worksView.classList.add("hidden");
                    charsView.classList.remove("hidden");
                    bg.style.transform = "translateX(100%)";
                    btnChars.classList.remove("opacity-50");
                    btnWorks.classList.add("opacity-50");
                }
            };

            function renderMyCharacters(filter = "") {
                const grid = document.getElementById("myCharsGrid");
                if (!grid) return;

                if (isCharBulkEditing) {
                    grid.classList.add("bulk-editing");
                } else {
                    grid.classList.remove("bulk-editing");
                }

                let fullList = [
                    ...(window.charactersGlobal || []),
                    ...(window.likedCharactersGlobal || []),
                    ...(window.interestedCharactersGlobal || []),
                    ...(window.dislikedCharactersGlobal || []),
                ];

                if (hideAssignedChars) {
                    fullList = fullList.filter(
                        (c) => !c.source_id && !c.sourceId,
                    );
                }

                let list = fullList.sort((a, b) =>
                    getDisplayTitle(a).localeCompare(getDisplayTitle(b)),
                );

                if (filter) {
                    const lowerFilter = filter.toLowerCase();
                    list = list.filter((c) => {
                        // Check character name
                        if (
                            getDisplayTitle(c)
                                .toLowerCase()
                                .includes(lowerFilter)
                        ) {
                            return true;
                        }
                        let sourceTitle = "";
                        const sourceId = c.source_id || c.sourceId;
                        if (sourceId) {
                            const sourceWork = window.localLibrary.find(
                                (w) => w.id === sourceId,
                            );
                            if (sourceWork) sourceTitle = sourceWork.title;
                        } else if (c.source) {
                            // Backwards compatibility
                            sourceTitle = c.source;
                        }
                        return sourceTitle.toLowerCase().includes(lowerFilter);
                    });
                }
                if (list.length > 0) {
                    grid.innerHTML = list
                        .map((i) => renderCard(i, "openCharEditor", true))
                        .join("");
                } else {
                    grid.innerHTML =
                        '<p class="col-span-full text-white/5 text-[10px] py-4 pl-2">Biblioteca de personajes vacía.</p>';
                }
            }
            document
                .getElementById("myCharsFilter")
                .addEventListener("input", (e) =>
                    renderMyCharacters(e.target.value),
                );

            document
                .getElementById("sagasFilter")
                .addEventListener("input", (e) =>
                    renderSagasPanel(e.target.value),
                );

            function renderSagaFavoriteCard(sagaItem) {
                return `
                <div class="asearch-card" data-issaga="true" data-title="${sagaItem.title}" data-cover="${sagaItem.cover}" draggable="false">
                    <img src="${sagaItem.cover}" class="obj-center" loading="lazy" draggable="false">
                    <div class="absolute top-1.5 right-1.5 text-[9px] font-bold uppercase bg-yellow-500/20 text-yellow-300 px-2 py-0.5 rounded-full border border-yellow-500/30">Saga</div>
                    <div class="asearch-info">
                        <h4 class="asearch-title">${sagaItem.title}</h4>
                    </div>
                </div>`;
            }

            function renderFavWorksSortable() {
                const container = document.getElementById("favList");

                if (window.favoritesTitles.length === 0) {
                    container.innerHTML =
                        '<p class="col-span-full text-center text-white/20 py-20">No tienes obras en favoritos aún.</p>';
                    return;
                }

                const listHtml = window.favoritesTitles
                    .map((fav) => {
                        const favIsObject =
                            typeof fav === "object" && fav !== null;
                        const favTitle = favIsObject ? fav.title : fav;
                        const isSaga =
                            favIsObject && (fav.is_saga || fav.isSaga);

                        if (isSaga) {
                            return renderSagaFavoriteCard(fav);
                        }

                        // It's a work. Find it in the library.
                        let item = window.localLibrary.find(
                            (i) => i.title === favTitle,
                        );
                        // Handle manga title discrepancy
                        if (!item) {
                            if (favTitle.endsWith(" -M")) {
                                item = window.localLibrary.find(
                                    (i) =>
                                        i.title === favTitle.slice(0, -3) &&
                                        i.type === "manga",
                                );
                            } else {
                                item = window.localLibrary.find(
                                    (i) =>
                                        `${i.title} -M` === favTitle &&
                                        i.type === "manga",
                                );
                            }
                        }

                        if (item) {
                            // Create a temporary item for the card with the correct favorite title for data-title
                            const itemForCard = { ...item, title: favTitle };
                            return renderCard(
                                itemForCard,
                                "openEditorLocal",
                                false,
                            );
                        }
                        return ""; // Or a placeholder for a missing item
                    })
                    .join("");

                container.innerHTML = listHtml;

                // Activamos la capacidad de arrastrar (Sortable)
                new Sortable(container, {
                    animation: 150,
                    ghostClass: "sortable-ghost-card",
                });
            }

            window.switchCharacterCategoryView = (category) => {
                activeCharCategory = category;
                document
                    .querySelectorAll(".category-tab-btn")
                    .forEach((btn) => btn.classList.remove("active"));
                document
                    .getElementById(`cat-btn-${category}`)
                    .classList.add("active");
                renderActiveCharList();
            };

            // --- Lógica de ordenación de personajes por saga ---
            const workToSagaMap = new Map();
            const sortedSagaNames = Object.keys(window.sagas).sort((a, b) =>
                a.localeCompare(b),
            );

            sortedSagaNames.forEach((sagaName) => {
                const worksInSaga = window.sagas[sagaName];
                worksInSaga.forEach((workTitle, index) => {
                    workToSagaMap.set(workTitle, {
                        sagaName,
                        workIndex: index,
                    });
                });
            });

            function getCharSagaInfo(character) {
                const sourceId = character.source_id || character.sourceId;
                if (!sourceId) return null;
                const sourceWork = window.localLibrary.find(
                    (w) => w.id === sourceId,
                );
                if (!sourceWork) return null;
                return workToSagaMap.get(sourceWork.title) || null;
            }

            function sortCharactersBySaga(charList) {
                const listCopy = [...charList];
                listCopy.sort((a, b) => {
                    const sagaA = getCharSagaInfo(a);
                    const sagaB = getCharSagaInfo(b);

                    if (sagaA && sagaB) {
                        if (sagaA.sagaName !== sagaB.sagaName) {
                            return sagaA.sagaName.localeCompare(sagaB.sagaName);
                        }
                        return sagaA.workIndex - sagaB.workIndex;
                    }
                    if (sagaA && !sagaB) return -1;
                    if (!sagaA && sagaB) return 1;
                    return a.title.localeCompare(b.title);
                });
                return listCopy;
            }

            function renderActiveCharList() {
                if (activeCharListSortable) {
                    activeCharListSortable.destroy();
                    activeCharListSortable = null;
                }

                const container = document.getElementById("activeCharList");
                let list = [];
                let isManuallySortable = false;

                switch (activeCharCategory) {
                    case "fav":
                        list = window.charactersGlobal;
                        isManuallySortable = true;
                        break;
                    case "liked":
                        list = sortCharactersBySaga(
                            window.likedCharactersGlobal,
                        );
                        break;
                    case "interested":
                        list = sortCharactersBySaga(
                            window.interestedCharactersGlobal,
                        );
                        break;
                    case "disliked":
                        list = sortCharactersBySaga(
                            window.dislikedCharactersGlobal,
                        );
                        break;
                }

                container.innerHTML =
                    list.length > 0
                        ? list
                              .map((item) => renderCard(item, "", true))
                              .join("") // Deshabilitar click
                        : '<p class="col-span-full text-center text-white/20 py-20 text-sm">Esta categoría está vacía.</p>';

                activeCharListSortable = new Sortable(container, {
                    group: "characters",
                    animation: 150,
                    ghostClass: "sortable-ghost-card",
                    sort: isManuallySortable, // Permite reordenar solo si es la lista manual
                    onStart: function () {
                        document.body.classList.add("is-dragging-active");
                    },
                    onEnd: (evt) => {
                        document.body.classList.remove("is-dragging-active");

                        // Si se reordena dentro de la misma lista manual ('fav')
                        if (isManuallySortable && evt.from === evt.to) {
                            const reorderedTitles = Array.from(
                                evt.to.querySelectorAll(".asearch-title"),
                            ).map((el) => el.innerText);

                            const reorderedChars = reorderedTitles
                                .map((title) =>
                                    window.charactersGlobal.find(
                                        (c) => c.title === title,
                                    ),
                                )
                                .filter(Boolean);

                            window.charactersGlobal = reorderedChars;
                        }
                        // El movimiento entre listas lo gestiona el 'onAdd' de los botones de categoría
                    },
                });
            }

            function setupCharacterFavoritesView() {
                // Update counters
                document.getElementById("fav-char-count").textContent =
                    window.charactersGlobal.length;
                document.getElementById("liked-char-count").textContent =
                    window.likedCharactersGlobal.length;
                document.getElementById("interested-char-count").textContent =
                    window.interestedCharactersGlobal.length;
                document.getElementById("disliked-char-count").textContent =
                    window.dislikedCharactersGlobal.length;

                switchCharacterCategoryView("fav");

                const moveCharacter = (title, targetCategory) => {
                    const allLists = {
                        fav: window.charactersGlobal,
                        liked: window.likedCharactersGlobal,
                        interested: window.interestedCharactersGlobal,
                        disliked: window.dislikedCharactersGlobal,
                    };
                    let character = null;
                    let sourceCategory = null;

                    for (const cat in allLists) {
                        const index = allLists[cat].findIndex(
                            (c) => c.title === title,
                        );
                        if (index > -1) {
                            character = allLists[cat].splice(index, 1)[0];
                            sourceCategory = cat;
                            break;
                        }
                    }

                    if (character) {
                        allLists[targetCategory].push(character);
                        if (sourceCategory === activeCharCategory) {
                            renderActiveCharList();
                        }
                        document.getElementById("fav-char-count").textContent =
                            allLists.fav.length;
                        document.getElementById(
                            "liked-char-count",
                        ).textContent = allLists.liked.length;
                        document.getElementById(
                            "interested-char-count",
                        ).textContent = allLists.interested.length;
                        document.getElementById(
                            "disliked-char-count",
                        ).textContent = allLists.disliked.length;
                    }
                };

                ["fav", "liked", "interested", "disliked"].forEach(
                    (category) => {
                        const dropZone = document.getElementById(
                            `cat-btn-${category}`,
                        );
                        new Sortable(dropZone, {
                            group: {
                                name: "characters",
                                pull: false,
                                put: true,
                            },
                            ghostClass: "sortable-ghost-hidden", // Also hide the ghost in the drop zone
                            onAdd: (evt) => {
                                const characterTitle =
                                    evt.item.querySelector(
                                        ".asearch-title",
                                    ).innerText;
                                moveCharacter(characterTitle, category);
                                evt.item.remove();
                            },
                        });
                    },
                );
            }

            window.switchFavView = (type) => {
                const worksView = document.getElementById("fav-works-view");
                const charsView = document.getElementById("fav-chars-view");
                const btnWorks = document.getElementById("btn-fav-works");
                const btnChars = document.getElementById("btn-fav-chars");
                const bg = document.getElementById("fav-tab-bg");

                if (type === "works") {
                    worksView.classList.remove("hidden");
                    charsView.classList.add("hidden");
                    bg.style.transform = "translateX(0)";
                    worksView.classList.add("flex");
                    btnWorks.classList.remove("opacity-50");
                    btnChars.classList.add("opacity-50");
                } else {
                    worksView.classList.add("hidden");
                    worksView.classList.remove("flex");
                    charsView.classList.remove("hidden");
                    bg.style.transform = "translateX(100%)";
                    btnChars.classList.remove("opacity-50");
                    btnWorks.classList.add("opacity-50");
                    setupCharacterFavoritesView();
                }
            };

            document
                .getElementById("saveCharOrderBtn")
                .addEventListener("click", async () => {
                    const btn = document.getElementById("saveCharOrderBtn");
                    const originalText = btn.innerHTML;
                    btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i>`;
                    btn.disabled = true;

                    try {
                        await fetch("/api/save.json", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                dbData: {
                                    characters: window.charactersGlobal,
                                    likedCharacters:
                                        window.likedCharactersGlobal,
                                    interestedCharacters:
                                        window.interestedCharactersGlobal,
                                    dislikedCharacters:
                                        window.dislikedCharactersGlobal,
                                },
                            }),
                        });
                        btn.innerHTML = `<i class="fa-solid fa-check"></i> ¡Guardado!`;
                        setTimeout(() => {
                            btn.innerHTML = originalText;
                            btn.disabled = false;
                        }, 2000);
                    } catch (e) {
                        console.error(e);
                        btn.innerHTML = "Error";
                        setTimeout(() => {
                            btn.innerHTML = originalText;
                            btn.disabled = false;
                        }, 2000);
                    }
                });

            document
                .getElementById("saveOrderBtn")
                .addEventListener("click", async () => {
                    const btn = document.getElementById("saveOrderBtn");
                    const originalText = btn.innerHTML;
                    btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Guardando...`;
                    btn.disabled = true;

                    const newOrder = [];
                    document
                        .querySelectorAll("#favList .asearch-card")
                        .forEach((card) => {
                            if (card.dataset.issaga === "true") {
                                newOrder.push({
                                    is_saga: true,
                                    title: card.dataset.title,
                                    cover: card.dataset.cover,
                                });
                            } else {
                                const title = card.dataset.title;
                                if (title) {
                                    newOrder.push({
                                        title: title,
                                        is_saga: false,
                                    });
                                }
                            }
                        });

                    window.favoritesTitles = newOrder;

                    try {
                        const res = await fetch("/api/save.json", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                dbData: { favorites: newOrder },
                            }),
                        });
                        if (!res.ok)
                            throw new Error(
                                "El servidor falló al guardar el orden.",
                            );

                        btn.innerHTML = `<i class="fa-solid fa-check"></i> ¡Guardado! Recargando...`;
                        setTimeout(() => {
                            window.location.reload();
                        }, 500);
                    } catch (e) {
                        console.error(e);
                        btn.innerHTML = "Error";
                        setTimeout(() => {
                            btn.innerHTML = originalText;
                            btn.disabled = false;
                        }, 2000);
                    }
                });

            // --- SAGAS ---
            function renderSagaItem(game) {
                if (!game) return "";
                return `
                    <div class="saga-item" data-title="${game.title}" title="${game.title}">
                        <img src="${game.cover}" class="saga-item-cover" loading="lazy">
                    </div>
                `;
            }

            function romanToArabic(s) {
                if (!s || typeof s !== "string") return null;
                const roman = s.toUpperCase();
                if (!/^[IVXLCDM]+$/.test(roman)) return null;
                const map = {
                    I: 1,
                    V: 5,
                    X: 10,
                    L: 50,
                    C: 100,
                    D: 500,
                    M: 1000,
                };
                let result = 0;
                for (let i = 0; i < roman.length; i++) {
                    const current = map[roman[i]];
                    const next = map[roman[i + 1]];
                    if (next && current < next) {
                        result -= current;
                    } else {
                        result += current;
                    }
                }
                return result;
            }

            function getSortValue(title) {
                const trimmedTitle = title.trim();
                let match = trimmedTitle.match(/^(.*)\s(F)$/i);
                if (match) return { value: 1000, base: match[1].trim() };
                match = trimmedTitle.match(/^(.*)\s(\d+)$/);
                if (match)
                    return {
                        value: parseInt(match[2], 10),
                        base: match[1].trim(),
                    };
                match = trimmedTitle.match(/^(.*)\s([IVXLCDM]+)$/i);
                if (match) {
                    const num = romanToArabic(match[2]);
                    if (num !== null) {
                        return { value: num, base: match[1].trim() };
                    }
                }
                return { value: 1, base: trimmedTitle };
            }

            function renderSagasPanel(filter = "") {
                const findItem = (title) =>
                    window.localLibrary.find((item) => item.title === title);

                // 1. Auto-assignment phase
                const allItemTitles = new Set(
                    window.localLibrary.map((item) => item.title),
                );
                const allSagaNames = Object.keys(window.sagas);
                let assignedInSagas = new Set(
                    Object.values(window.sagas).flat(),
                );
                let currentlyUnassigned = new Set(
                    [...allItemTitles].filter(
                        (title) => !assignedInSagas.has(title),
                    ),
                );

                const modifiedSagas = new Set();

                for (const sagaName of allSagaNames) {
                    const titlesToMove = [];
                    for (const unassignedTitle of currentlyUnassigned) {
                        const { base } = getSortValue(unassignedTitle);
                        if (base.toLowerCase() === sagaName.toLowerCase()) {
                            titlesToMove.push(unassignedTitle);
                        }
                    }

                    if (titlesToMove.length > 0) {
                        window.sagas[sagaName].push(...titlesToMove);
                        titlesToMove.forEach((title) =>
                            currentlyUnassigned.delete(title),
                        );
                        modifiedSagas.add(sagaName);
                    }
                }

                // Process sagas: remove duplicates and sort only if modified
                for (const sagaName in window.sagas) {
                    window.sagas[sagaName] = [
                        ...new Set(window.sagas[sagaName]),
                    ]; // Remove duplicates

                    if (modifiedSagas.has(sagaName)) {
                        window.sagas[sagaName].sort((a, b) => {
                            const valA = getSortValue(a).value;
                            const valB = getSortValue(b).value;
                            return valB - valA; // Descending
                        });
                    }
                }

                // 2. Categorize remaining unassigned
                const suggestedTitles = [];
                const trulyUnassignedTitles = [];
                const sagaNamesLower = allSagaNames.map((s) => s.toLowerCase());

                for (const title of currentlyUnassigned) {
                    let isSuggestion = false;
                    for (const sagaName of sagaNamesLower) {
                        if (title.toLowerCase().includes(sagaName)) {
                            isSuggestion = true;
                            break;
                        }
                    }
                    if (isSuggestion) {
                        suggestedTitles.push(title);
                    } else {
                        trulyUnassignedTitles.push(title);
                    }
                }

                // 3. Render UI
                const unassignedContainer =
                    document.getElementById("unassigned-games");
                const suggestedContainer =
                    document.getElementById("suggested-games");
                const sagasContainer =
                    document.getElementById("sagas-container");

                unassignedContainer.innerHTML = trulyUnassignedTitles
                    .map(findItem)
                    .filter(Boolean)
                    .map(renderSagaItem)
                    .join("");
                suggestedContainer.innerHTML = suggestedTitles
                    .map(findItem)
                    .filter(Boolean)
                    .map(renderSagaItem)
                    .join("");

                let sagaEntries = Object.entries(window.sagas);
                if (filter) {
                    const lowerFilter = filter.toLowerCase();
                    sagaEntries = sagaEntries.filter(([sagaName, _]) =>
                        sagaName.toLowerCase().includes(lowerFilter),
                    );
                }

                sagasContainer.innerHTML = sagaEntries
                    .sort((a, b) => a[0].localeCompare(b[0]))
                    .map(([sagaName, games]) => {
                        const isFav = window.favoritesTitles.some(
                            (fav) =>
                                fav &&
                                (fav.is_saga || fav.isSaga) &&
                                fav.title === sagaName,
                        );
                        const gameObjects = games.map(findItem).filter(Boolean);

                        let hasAnime = false;
                        let hasManga = false;
                        let hasGames = false;
                        let hasEpisodicGame = false;

                        gameObjects.forEach((item) => {
                            if (item.type === "anime") hasAnime = true;
                            if (item.type === "manga") hasManga = true;
                            if (item.type === "games") {
                                hasGames = true;
                                const lowerTitle = item.title.toLowerCase();
                                if (
                                    lowerTitle.includes("episode") ||
                                    lowerTitle.includes("chapter")
                                ) {
                                    hasEpisodicGame = true;
                                }
                            }
                        });

                        let sagaTag = "";
                        let tagClass = "";

                        if (hasAnime && hasManga && hasGames) {
                            sagaTag = "Franquicia";
                            tagClass = "saga-tag--franchise";
                        } else if (hasAnime && hasManga) {
                            sagaTag = "Obra y adaptación";
                            tagClass = "saga-tag--adaptation";
                        } else if (hasGames && !hasAnime && !hasManga) {
                            if (hasEpisodicGame) {
                                sagaTag = "Obra completa";
                                tagClass = "saga-tag--complete";
                            } else {
                                sagaTag = "Saga";
                                tagClass = "saga-tag--saga";
                            }
                        } else if (
                            (hasAnime && !hasManga && !hasGames) ||
                            (!hasAnime && hasManga && !hasGames)
                        ) {
                            sagaTag = "Obra completa";
                            tagClass = "saga-tag--complete";
                        }

                        return `
                        <div class="saga-container" data-saga-name="${sagaName}">
                            <div class="saga-header">
                                <div class="flex items-center gap-2 flex-1 min-w-0">
                                    <input type="text" class="saga-title-input" value="${sagaName}">
                                </div>
                                <div class="flex items-center gap-3">
                                    ${
                                        sagaTag
                                            ? `<div class="saga-tag-strip ${tagClass}" data-tag-text="${sagaTag}" title="${sagaTag}"></div>`
                                            : ""
                                    }
                                    <i class="fa-solid fa-star cursor-pointer ${
                                        isFav
                                            ? "text-yellow-400"
                                            : "text-gray-600 hover:text-yellow-400"
                                    }" title="Marcar como Favorito" onclick="toggleSagaFavorite('${sagaName}', this)"></i>
                                    <i class="fa-solid fa-trash-can delete-saga-btn" onclick="this.closest('.saga-container').remove()"></i>
                                </div>
                            </div>
                            <div class="saga-list">
                                ${gameObjects.map(renderSagaItem).join("")}
                            </div>
                        </div>
                    `;
                    })
                    .join("");

                // Init Sortable
                new Sortable(unassignedContainer, {
                    group: "sagas",
                    animation: 150,
                    ghostClass: "sortable-ghost",
                    scroll: true, // Habilita el auto-scroll
                    scrollSensitivity: 60, // Distancia en px desde el borde para iniciar el scroll
                    scrollSpeed: 15, // Velocidad del scroll
                });
                new Sortable(suggestedContainer, {
                    group: "sagas",
                    animation: 150,
                    ghostClass: "sortable-ghost",
                    scroll: true,
                    scrollSensitivity: 60,
                    scrollSpeed: 15,
                });
                document
                    .querySelectorAll("#sagas-container .saga-list")
                    .forEach((el) => {
                        new Sortable(el, {
                            group: "sagas",
                            animation: 150,
                            ghostClass: "sortable-ghost",
                            scroll: true,
                            scrollSensitivity: 60,
                            scrollSpeed: 15,
                        });
                    });

                setupSagaScroll();
            }

            function setupSagaScroll() {
                document
                    .querySelectorAll(".saga-container .saga-list")
                    .forEach((list) => {
                        // Solo aplicar a listas que realmente desbordan
                        if (list.scrollWidth > list.clientWidth) {
                            list.addEventListener(
                                "wheel",
                                (e) => {
                                    // Prevenir el scroll de la página si estamos actuando sobre el carrusel
                                    e.preventDefault();

                                    // Calcular la cantidad de scroll (ancho de 4 items + sus gaps)
                                    const itemWidth = 64; // Ancho fijo del .saga-item
                                    const gap = 6; // Gap entre items
                                    const scrollAmount = (itemWidth + gap) * 4;
                                    // Determinar la dirección del scroll. Priorizamos deltaX (scroll horizontal nativo)
                                    // y usamos deltaY como fallback (rueda del ratón).
                                    const scrollDirection = Math.sign(
                                        e.deltaX !== 0 ? e.deltaX : e.deltaY,
                                    );
                                    // Aplicamos el scroll con animación suave
                                    list.scrollBy({
                                        left: scrollAmount * scrollDirection,
                                        behavior: "smooth",
                                    });
                                },
                                { passive: false },
                            ); // passive: false es necesario para preventDefault
                        }
                    });
            }
            document
                .getElementById("addSagaBtn")
                .addEventListener("click", () => {
                    const sagasContainer =
                        document.getElementById("sagas-container");
                    const newSagaName = `Nueva Saga ${Object.keys(window.sagas).length + 1}`;
                    const newSagaEl = document.createElement("div");
                    newSagaEl.className = "saga-container";
                    newSagaEl.dataset.sagaName = newSagaName;
                    newSagaEl.innerHTML = `
                    <div class="saga-header">
                        <input type="text" class="saga-title-input" value="${newSagaName}"> 
                        <i class="fa-solid fa-trash-can delete-saga-btn" onclick="this.closest('.saga-container').remove()"></i>
                    </div> 
                    <div class="saga-list"></div>
                `;
                    sagasContainer.appendChild(newSagaEl);
                    new Sortable(newSagaEl.querySelector(".saga-list"), {
                        group: "sagas",
                        animation: 150,
                        ghostClass: "sortable-ghost",
                    });
                });

            document
                .getElementById("saveSagasBtn")
                .addEventListener("click", async () => {
                    const btn = document.getElementById("saveSagasBtn");
                    const originalText = btn.innerHTML;
                    btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i>`;
                    btn.disabled = true;

                    const newSagas = {};
                    document
                        .querySelectorAll("#sagas-container .saga-container")
                        .forEach((container) => {
                            const sagaName = container
                                .querySelector(".saga-title-input")
                                .value.trim();
                            if (sagaName) {
                                const games = Array.from(
                                    container.querySelectorAll(".saga-item"),
                                ).map((item) => item.dataset.title);
                                newSagas[sagaName] = games;
                            }
                        });

                    window.sagas = newSagas;

                    try {
                        await fetch("/api/save.json", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                dbData: { sagas: newSagas },
                            }),
                        });
                        btn.innerHTML = `<i class="fa-solid fa-check"></i>`;
                        setTimeout(() => {
                            btn.innerHTML = originalText;
                            btn.disabled = false;
                        }, 2000);
                    } catch (e) {
                        console.error(e);
                        btn.innerHTML = "Error";
                        setTimeout(() => {
                            btn.innerHTML = originalText;
                            btn.disabled = false;
                        }, 2000);
                    }
                });

            // --- BUSCADOR DE PERSONAJES ---
            const charForm = document.getElementById("charSearchForm");

            if (charForm) {
                charForm.addEventListener("submit", async (e) => {
                    e.preventDefault(); // CRÍTICO: Evita que el Enter te lleve a otro lado

                    const q = document.getElementById("charInput").value;
                    if (!q) return;

                    const resultsGrid = document.getElementById("charResults");
                    resultsGrid.innerHTML =
                        '<p class="col-span-full text-indigo-400 text-xs py-4 text-center animate-pulse">Buscando...</p>';

                    try {
                        const res = await fetch(
                            `/api/search.json?q=${encodeURIComponent(q)}&type=character`,
                        );
                        const data = await res.json();

                        if (!data || data.length === 0) {
                            resultsGrid.innerHTML =
                                '<p class="col-span-full text-white/20 text-xs py-4 text-center">No se encontraron personajes.</p>';
                        } else {
                            // Usamos la función renderCard que ya tienes, pasando true al final para indicar que es personaje
                            resultsGrid.innerHTML = data
                                .map((i) =>
                                    renderCard(i, "openCharEditor", true),
                                )
                                .join("");
                        }
                    } catch (e) {
                        console.error("Error en la búsqueda:", e);
                        resultsGrid.innerHTML =
                            '<p class="col-span-full text-red-500/50 text-xs py-4 text-center">Error de conexión con el servidor.</p>';
                    }
                });
            }

            document
                .getElementById("deleteCharBtn")
                .addEventListener("click", async () => {
                    if (!currentSelection || !currentSelection.id) return;
                    if (
                        !confirm(
                            `¿Seguro que quieres eliminar a "${currentSelection.title}" de todas las listas?`,
                        )
                    )
                        return;

                    // Remove from all lists
                    window.charactersGlobal = window.charactersGlobal.filter(
                        (c) => c.id !== currentSelection.id,
                    );
                    window.likedCharactersGlobal =
                        window.likedCharactersGlobal.filter(
                            (c) => c.id !== currentSelection.id,
                        );
                    window.interestedCharactersGlobal =
                        window.interestedCharactersGlobal.filter(
                            (c) => c.id !== currentSelection.id,
                        );
                    window.dislikedCharactersGlobal =
                        window.dislikedCharactersGlobal.filter(
                            (c) => c.id !== currentSelection.id,
                        );
                    window.monthlyCharsGlobal =
                        window.monthlyCharsGlobal.filter(
                            (p) => p.name !== currentSelection.title,
                        );

                    await saveAllCharacterLists();
                    closeCharEditor();
                    renderMyCharacters();
                    setupCharacterFavoritesView();
                });
            // --- GUARDAR PERSONAJE ---
            document
                .getElementById("saveCharBtn")
                .addEventListener("click", async () => {
                    if (!currentSelection) return;

                    const name = document.getElementById("charNameInput").value;
                    const coverOffsetY = document.getElementById(
                        "charCoverOffsetYRange",
                    ).value;

                    const updatedChar = {
                        ...currentSelection,
                        title: name,
                        coverOffsetY: Number(coverOffsetY),
                    };

                    // Asignar el sourceId y eliminar el source antiguo para evitar inconsistencias
                    updatedChar.sourceId =
                        currentSelection.sourceId ||
                        currentSelection.source_id ||
                        null;
                    if ("source" in updatedChar) delete updatedChar.source;

                    const favIndex = window.charactersGlobal.findIndex(
                        (c) => c.id === updatedChar.id,
                    );
                    const likedIndex = window.likedCharactersGlobal.findIndex(
                        (c) => c.id === updatedChar.id,
                    );
                    const interestedIndex =
                        window.interestedCharactersGlobal.findIndex(
                            (c) => c.id === updatedChar.id,
                        );
                    const dislikedIndex =
                        window.dislikedCharactersGlobal.findIndex(
                            (c) => c.id === updatedChar.id,
                        );

                    if (favIndex > -1) {
                        window.charactersGlobal[favIndex] = updatedChar;
                    } else if (likedIndex > -1) {
                        window.likedCharactersGlobal[likedIndex] = updatedChar;
                    } else if (interestedIndex > -1) {
                        window.interestedCharactersGlobal[interestedIndex] =
                            updatedChar;
                    } else if (dislikedIndex > -1) {
                        window.dislikedCharactersGlobal[dislikedIndex] =
                            updatedChar;
                    } else {
                        // Por defecto, un personaje nuevo se añade a "Me Gustan"
                        window.likedCharactersGlobal.push(updatedChar);
                    }

                    try {
                        await saveAllCharacterLists();
                        closeCharEditor();
                        if (
                            !document
                                .getElementById("my-characters-panel")
                                .classList.contains("hidden")
                        ) {
                            renderMyCharacters(
                                document.getElementById("myCharsFilter").value,
                            );
                        }
                    } catch (e) {
                        console.error("Error saving character:", e);
                        alert("Error al guardar el personaje.");
                    }
                });

            document
                .getElementById("workPickerFilter")
                .addEventListener("input", (e) =>
                    renderWorkPickerGrid(e.target.value),
                );

            async function saveAllCharacterLists() {
                const payload = {
                    dbData: {
                        characters: window.charactersGlobal,
                        likedCharacters: window.likedCharactersGlobal,
                        dislikedCharacters: window.dislikedCharactersGlobal,
                        interestedCharacters: window.interestedCharactersGlobal,
                        monthlyChars: window.monthlyCharsGlobal,
                    },
                };
                const res = await fetch("/api/save.json", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload),
                });
                if (!res.ok) {
                    throw new Error(
                        "Server error while saving character lists",
                    );
                }
            }

            document
                .getElementById("deleteMediaBtn")
                .addEventListener("click", async () => {
                    if (!currentSelection || !currentSelection.id) return;

                    if (
                        !confirm(
                            `¿Seguro que quieres eliminar "${currentSelection.title}" de tu colección? Esta acción no se puede deshacer.`,
                        )
                    ) {
                        return;
                    }

                    const btn = document.getElementById("deleteMediaBtn");
                    const originalText = btn.innerText;
                    btn.innerText = "Eliminando...";
                    btn.disabled = true;

                    try {
                        const deleteRes = await fetch("/api/delete.json", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                type: currentSelection.type,
                                id: currentSelection.id,
                            }),
                        });
                        if (!deleteRes.ok)
                            throw new Error("File deletion failed");

                        window.favoritesTitles = window.favoritesTitles.filter(
                            (t) => {
                                // For manga, we need to check for both "Title" and "Title -M"
                                if (typeof t === "string") {
                                    return (
                                        t !== currentSelection.title &&
                                        t !== `${currentSelection.title} -M`
                                    );
                                }
                                // Keep saga objects
                                return true;
                            },
                        );
                        window.monthlyPicksGlobal =
                            window.monthlyPicksGlobal.filter(
                                (p) => p.title !== currentSelection.title,
                            );

                        const saveDbRes = await fetch("/api/save.json", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                dbData: {
                                    favorites: window.favoritesTitles,
                                    monthlyPicks: window.monthlyPicksGlobal,
                                },
                            }),
                        });
                        if (!saveDbRes.ok) throw new Error("DB update failed");

                        btn.innerText = "¡Eliminado!";
                        setTimeout(() => window.location.reload(), 500);
                    } catch (e) {
                        console.error("Error deleting item:", e);
                        alert("Error al eliminar la obra.");
                        btn.innerText = originalText;
                        btn.disabled = false;
                    }
                });

            switchMode(previousActiveTab);

            // --- Custom Slider Logic ---
            function setSliderPosition(thumbId, value) {
                const thumb = document.getElementById(thumbId);
                if (thumb) {
                    const percentage = 100 - value; // Invert value for top position
                    thumb.style.top = `calc(${percentage}% - 8px)`;
                }
            }

            function initCustomSlider(containerId, thumbId, onUpdate) {
                const container = document.getElementById(containerId);
                const thumb = document.getElementById(thumbId);
                if (!container || !thumb) return;

                let isDragging = false;

                const onDrag = (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    const rect = container.getBoundingClientRect();
                    const y = (e.clientY || e.touches[0].clientY) - rect.top;
                    const percentage = Math.max(
                        0,
                        Math.min(100, (y / rect.height) * 100),
                    );

                    thumb.style.top = `calc(${percentage}% - 8px)`;
                    onUpdate(100 - percentage); // Invert for object-position
                };

                const stopDrag = () => {
                    isDragging = false;
                    document.removeEventListener("mousemove", onDrag);
                    document.removeEventListener("mouseup", stopDrag);
                    document.removeEventListener("touchmove", onDrag);
                    document.removeEventListener("touchend", stopDrag);
                };

                const startDrag = (e) => {
                    e.preventDefault();
                    isDragging = true;
                    document.addEventListener("mousemove", onDrag);
                    document.addEventListener("mouseup", stopDrag);
                    document.addEventListener("touchmove", onDrag);
                    document.addEventListener("touchend", stopDrag);
                };

                thumb.addEventListener("mousedown", startDrag);
                thumb.addEventListener("touchstart", startDrag);
                container.addEventListener("click", (e) => {
                    if (e.target === thumb) return;
                    const rect = container.getBoundingClientRect();
                    const y = e.clientY - rect.top;
                    const percentage = Math.max(
                        0,
                        Math.min(100, (y / rect.height) * 100),
                    );
                    thumb.style.top = `calc(${percentage}% - 8px)`;
                    onUpdate(100 - percentage);
                });
            }

            initCustomSlider(
                "custom-slider-container",
                "custom-slider-thumb",
                (pos) => {
                    const position = Math.round(pos);
                    document.getElementById(
                        "editorPreviewCover",
                    ).style.objectPosition = `center ${position}%`;
                    document.getElementById("coverOffsetText").innerText =
                        `${position}%`;
                    document.getElementById("coverOffsetYRange").value =
                        position;
                },
            );

            initCustomSlider(
                "char-custom-slider-container",
                "char-custom-slider-thumb",
                (pos) => {
                    const position = Math.round(pos);
                    document.getElementById(
                        "charEditorPreviewCover",
                    ).style.objectPosition = `center ${position}%`;
                    document.getElementById("charCoverOffsetText").innerText =
                        `${position}%`;
                    document.getElementById("charCoverOffsetYRange").value =
                        position;
                },
            );
            function updateCharCoverOffset(pos) {
                const position = Math.round(pos);
                document.getElementById(
                    "charEditorPreviewCover",
                ).style.objectPosition = `center ${position}%`;
                document.getElementById("charCoverOffsetText").innerText =
                    `${position}%`;
                document.getElementById("charCoverOffsetYRange").value =
                    position;
            }

            // Inicializar el nuevo gestor de subida de imágenes
            setupImageUploader();

            // Auto-update finish date year based on start date year
            document
                .getElementById("startDate")
                .addEventListener("change", (e) => {
                    const startDateValue = e.target.value;
                    if (!startDateValue) return;

                    const startYear = startDateValue.substring(0, 4);

                    const finishDateInput =
                        document.getElementById("finishDate");
                    const finishDateValue = finishDateInput.value;

                    if (finishDateValue) {
                        const restOfFinishDate = finishDateValue.substring(4); // -MM-DD
                        finishDateInput.value = `${startYear}${restOfFinishDate}`;
                    }
                });
        </script>
    </body>
</html>
