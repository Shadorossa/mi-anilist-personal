---
import fs from "node:fs";
import path from "node:path";
import * as Vibrant from "node-vibrant/node";

// Componentes
import ProfileHeader from "../components/ProfileHeader.astro";
import HallOfFame from "../components/HallOfFame.astro";
import MonthlyHistory from "../components/MonthlyHistory.astro"; // <-- IMPORTAR EL NUEVO
import TimeTravel from "../components/TimeTravel.astro";
import SectionWrapper from "../components/SectionWrapper.astro";
import LibraryGrid from "../components/LibraryGrid.astro";

// 1. CONFIGURACIÓN
let profile = { username: "Admin", bio: "Cargando..." };
try {
    const config = await import("../content/config.json");
    profile = config.default || config;
} catch (e) {}

// 2. DB
let db = {
    favorites: [],
    monthlyPicks: [],
    characters: [],
    monthlyChars: [],
    interestedCharacters: [],
    dislikedCharacters: [],
    decoPairs: [],
    decoGroups: [],
};
try {
    const d = await import("../content/database.json");
    db = d.default || d;
} catch (e) {}

const bannerPath = "/img/profile/banner.png";
const avatarPath = "/img/profile/pic.png";

let accentColor = "#a78bfa"; // Default (violet-400)
let accentColorRgb = "167, 139, 250";

function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result
        ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(
              result[3],
          )}`
        : null;
}

try {
    const palette = await Vibrant.from(`./public${bannerPath}`).getPalette();
    const vibrantColor =
        palette.Vibrant?.hex || palette.Muted?.hex || palette.LightVibrant?.hex;
    if (vibrantColor) {
        accentColor = vibrantColor;
        accentColorRgb = hexToRgb(vibrantColor) || accentColorRgb;
    }
} catch (e) {}

function resolveImagePath(basePath) {
    if (
        !basePath ||
        basePath.startsWith("http") ||
        /\.\w{3,4}$/.test(basePath)
    ) {
        return basePath; // It's a full URL or already has an extension.
    }
    const publicDir = path.resolve("./public");
    const potentialPath = path.join(publicDir, basePath);
    const dir = path.dirname(potentialPath);
    const slug = path.basename(potentialPath);

    const commonExtensions = [".png", ".jpg", ".jpeg", ".gif", ".webp"];
    for (const ext of commonExtensions) {
        if (fs.existsSync(path.join(dir, `${slug}${ext}`)))
            return `${basePath}${ext}`;
    }
    return basePath; // Fallback to original path if not found.
}

function readCollection(collectionName) {
    const dirPath = path.resolve(`./src/content/${collectionName}`);
    if (!fs.existsSync(dirPath)) return [];
    const files = fs.readdirSync(dirPath);
    return files
        .filter((file) => file.endsWith(".json"))
        .map((file) => {
            try {
                const filePath = path.join(dirPath, file);
                const content = fs.readFileSync(filePath, "utf-8");
                const data = JSON.parse(content);
                const type =
                    collectionName === "games" ? "game" : collectionName;
                return { ...data, id: file, type: type };
            } catch (e) {
                return null;
            }
        })
        .filter((item) => item !== null);
}

// 3. OBRAS
const allContent = [
    ...readCollection("games"),
    ...readCollection("anime"),
    ...readCollection("manga"),
];

const stats = {
    total: allContent.length,
    playing: allContent.filter(
        (i) =>
            i.status === "Jugando" ||
            i.status === "Viendo" ||
            i.status === "Leyendo",
    ).length,
    completed: allContent.filter((i) => i.status === "Completado").length,
    pending: allContent.filter((i) => i.status === "Pendiente").length,
    dropped: allContent.filter((i) => i.status === "Abandonado").length,
    paused: allContent.filter((i) => i.status === "Pausado").length,
    favs: db.favorites.length,
};

const timeTravelData = Object.entries(
    allContent
        .filter((item) => item.status === "Completado" && item.finishDate)
        .reduce((acc, item) => {
            const year = item.finishDate.substring(0, 4);
            if (year) {
                acc[year] = (acc[year] || 0) + 1;
            }
            return acc;
        }, {}),
)
    .map(([year, count]) => ({ year: parseInt(year), count }))
    .sort((a, b) => a.year - b.year);

// 4. FAVORITOS
const favorites = (db.favorites || [])
    .map((fav) => {
        if (typeof fav === "string") {
            const item = allContent.find((contentItem) => {
                // For manga, check against both "Title" and "Title -M"
                if (contentItem.type === "manga") {
                    return (
                        contentItem.title === fav ||
                        `${contentItem.title} -M` === fav
                    );
                }
                return contentItem.title === fav;
            });
            return item;
        }
        if (typeof fav === "object" && fav.isSaga) {
            const sagaTitles = db.sagas?.[fav.title] || [];
            if (sagaTitles.length > 0) {
                const sagaItems = sagaTitles
                    .map((title) =>
                        allContent.find((item) => item.title === title),
                    )
                    .filter(Boolean);
                if (
                    sagaItems.length > 0 &&
                    sagaItems.every(
                        (item) =>
                            item.type === "anime" || item.type === "manga",
                    )
                ) {
                    return { ...fav, isAnimeCollection: true };
                }
            }
            return fav;
        }
        return null;
    })
    .filter(Boolean);

// 5. MENSUALES (OBRAS)
const monthlyWorks = (db.monthlyPicks || [])
    .map((pick) => {
        const fullItem = allContent.find((item) => item.title === pick.title);
        const [y, m] = pick.month.split("-");
        const dateObj = new Date(parseInt(y), parseInt(m) - 1);
        const monthName = dateObj
            .toLocaleString("es-ES", { month: "short" })
            .toUpperCase()
            .replace(".", "");
        return {
            title: pick.title,
            cover: fullItem?.cover || pick.cover,
            year: y,
            month: monthName,
            rawDate: pick.month,
            coverOffsetY: fullItem?.coverOffsetY,
        };
    })
    .sort((a, b) => b.rawDate.localeCompare(a.rawDate));

// 6. MENSUALES (PERSONAJES)
const allDbChars = [...(db.characters || []), ...(db.likedCharacters || [])];
const monthlyChars = (db.monthlyChars || [])
    .map((pick) => {
        const fullChar = allDbChars.find((c) => c.title === pick.name);
        const [y, m] = pick.month.split("-");
        const dateObj = new Date(parseInt(y), parseInt(m) - 1);
        const monthName = dateObj
            .toLocaleString("es-ES", { month: "short" })
            .toUpperCase()
            .replace(".", "");
        return {
            title: pick.name,
            cover: resolveImagePath(pick.cover),
            year: y,
            month: monthName,
            rawDate: pick.month,
            coverOffsetY: fullChar?.coverOffsetY,
        };
    })
    .sort((a, b) => b.rawDate.localeCompare(a.rawDate));

// 7. HALL OF FAME PERSONAJES
const worksMap = new Map(allContent.map((work) => [work.id, work.title]));

const getSourceTitle = (char) => {
    if (char.sourceId) {
        return worksMap.get(char.sourceId);
    }
    return char.source; // Backwards compatibility
};

let customCharacters = [];
if (db.characters && db.characters.length > 0) {
    customCharacters = db.characters.map((c) => ({
        ...c,
        name: c.title,
        img: resolveImagePath(c.cover),
    }));
} else {
    customCharacters = [
        {
            name: "Malenia",
            source: "Elden Ring",
            img: "https://placehold.co/400x600",
        },
    ];
}

let likedCharacters = [];
if (db.likedCharacters && db.likedCharacters.length > 0) {
    likedCharacters = db.likedCharacters
        .map((c) => ({
            ...c,
            name: c.title,
            img: resolveImagePath(c.cover),
        }))
        .sort((a, b) => {
            const sourceA = getSourceTitle(a) || "";
            const sourceB = getSourceTitle(b) || "";
            const sourceCompare = sourceA.localeCompare(sourceB);
            if (sourceCompare !== 0) return sourceCompare;
            return a.name.localeCompare(b.name);
        });
}

let interestedCharacters = [];
if (db.interestedCharacters && db.interestedCharacters.length > 0) {
    interestedCharacters = db.interestedCharacters
        .map((c) => ({
            ...c,
            name: c.title,
            img: resolveImagePath(c.cover),
        }))
        .sort((a, b) => {
            const sourceA = getSourceTitle(a) || "";
            const sourceB = getSourceTitle(b) || "";
            const sourceCompare = sourceA.localeCompare(sourceB);
            if (sourceCompare !== 0) return sourceCompare;
            return a.name.localeCompare(b.name);
        });
}

let dislikedCharacters = [];
if (db.dislikedCharacters && db.dislikedCharacters.length > 0) {
    dislikedCharacters = db.dislikedCharacters
        .map((c) => ({
            ...c,
            name: c.title,
            img: resolveImagePath(c.cover),
        }))
        .sort((a, b) => {
            const sourceA = getSourceTitle(a) || "";
            const sourceB = getSourceTitle(b) || "";
            const sourceCompare = sourceA.localeCompare(sourceB);
            if (sourceCompare !== 0) return sourceCompare;
            return a.name.localeCompare(b.name);
        });
}

// 8. IMÁGENES DECORATIVAS
const getDecoImages = (side) => {
    const dirPath = path.resolve(`./public/img/profile/${side}-deco`);
    if (!fs.existsSync(dirPath)) return [];
    return fs
        .readdirSync(dirPath)
        .map((file) => `/img/profile/${side}-deco/${file}`);
};

const leftDecoImages = getDecoImages("left");
const rightDecoImages = getDecoImages("right");
const centerDecoImages = getDecoImages("center");

let randomLeftDeco = null;
let randomRightDeco = null;
let randomCenterDeco = null;

const getBasename = (fullPath) =>
    fullPath ? path.basename(fullPath, path.extname(fullPath)) : null;

const allDecoImagesMap = new Map();
[...leftDecoImages, ...rightDecoImages, ...centerDecoImages].forEach((p) => {
    if (p) allDecoImagesMap.set(getBasename(p), p);
});

// 1. Define available layout types and check for valid entries
const layoutOptions = [];
const decoGroups = db.decoGroups || [];
const decoPairs = db.decoPairs || [];

const validGroups = decoGroups.filter((group) => {
    if (group.length < 2) return false;
    const imagePaths = group.map((name) => allDecoImagesMap.get(name));
    if (imagePaths.some((p) => !p)) return false; // Check if all images were found

    const hasLeft = imagePaths.some((p) => p.includes("/left-deco/"));
    const hasRight = imagePaths.some((p) => p.includes("/right-deco/"));
    return hasLeft && hasRight;
});
if (validGroups.length > 0) {
    layoutOptions.push("group");
}

const validPairs = decoPairs.filter((pair) => {
    if (pair.length !== 2) return false;
    const img1Path = allDecoImagesMap.get(pair[0]);
    const img2Path = allDecoImagesMap.get(pair[1]);
    if (!img1Path || !img2Path) return false;
    const isImg1Left = img1Path.includes("/left-deco/");
    const isImg2Left = img2Path.includes("/left-deco/");
    const isImg1Right = img1Path.includes("/right-deco/");
    const isImg2Right = img2Path.includes("/right-deco/");
    return (isImg1Left && isImg2Right) || (isImg2Left && isImg1Right);
});
if (validPairs.length > 0) {
    layoutOptions.push("pair");
}

if (
    centerDecoImages.length > 0 ||
    (leftDecoImages.length > 0 && rightDecoImages.length > 0)
) {
    layoutOptions.push("normal");
}

// 2. Choose a layout if options are available
if (layoutOptions.length > 0) {
    const chosenLayout =
        layoutOptions[Math.floor(Math.random() * layoutOptions.length)];

    if (chosenLayout === "group") {
        const group =
            validGroups[Math.floor(Math.random() * validGroups.length)];
        const groupImagePaths = group.map((name) => allDecoImagesMap.get(name));
        const leftImagesInGroup = groupImagePaths.filter((p) =>
            p.includes("/left-deco/"),
        );
        const rightImagesInGroup = groupImagePaths.filter((p) =>
            p.includes("/right-deco/"),
        );
        randomLeftDeco =
            leftImagesInGroup[
                Math.floor(Math.random() * leftImagesInGroup.length)
            ];
        randomRightDeco =
            rightImagesInGroup[
                Math.floor(Math.random() * rightImagesInGroup.length)
            ];
    } else if (chosenLayout === "pair") {
        const pair = validPairs[Math.floor(Math.random() * validPairs.length)];
        const img1Path = allDecoImagesMap.get(pair[0]);
        const img2Path = allDecoImagesMap.get(pair[1]);
        if (img1Path.includes("/left-deco/")) {
            randomLeftDeco = img1Path;
            randomRightDeco = img2Path;
        } else {
            randomLeftDeco = img2Path;
            randomRightDeco = img1Path;
        }
    } else {
        // 'normal' layout
        const showCenter = Math.random() < 0.4 && centerDecoImages.length > 0;
        if (showCenter) {
            randomCenterDeco =
                centerDecoImages[
                    Math.floor(Math.random() * centerDecoImages.length)
                ];
        } else if (leftDecoImages.length > 0 && rightDecoImages.length > 0) {
            const pairedOrGroupedImages = new Set([
                ...decoPairs.flat(),
                ...decoGroups.flat(),
            ]);
            const availableLeft = leftDecoImages.filter(
                (p) => !pairedOrGroupedImages.has(getBasename(p)),
            );
            const availableRight = rightDecoImages.filter(
                (p) => !pairedOrGroupedImages.has(getBasename(p)),
            );
            const leftList =
                availableLeft.length > 0 ? availableLeft : leftDecoImages;
            const rightList =
                availableRight.length > 0 ? availableRight : rightDecoImages;
            randomLeftDeco =
                leftList[Math.floor(Math.random() * leftList.length)];
            randomRightDeco =
                rightList[Math.floor(Math.random() * rightList.length)];
        }
    }
}
---

<html
    lang="es"
    class="dark"
    style={`--accent-color: ${accentColor}; --accent-color-rgb: ${accentColorRgb};`}
>
    <head>
        <meta charset="UTF-8" />
        <title>{profile.username} | Colección</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
        />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&display=swap"
            rel="stylesheet"
        />
        <style>
            body {
                background-color: #050505;
                color: #e4e4e7;
                background-image: radial-gradient(
                    circle at 50% 0%,
                    #1a1a20 0%,
                    #050505 70%
                );
            }
            .hide-scroll::-webkit-scrollbar {
                display: none;
            }
            .mask-fade-sides {
                -webkit-mask-image: linear-gradient(
                    to right,
                    transparent,
                    black 25%,
                    black 75%,
                    transparent
                );
                mask-image: linear-gradient(
                    to right,
                    transparent,
                    black 25%,
                    black 75%,
                    transparent
                );
            }
        </style>
    </head>
    <body
        class="font-sans min-h-screen pb-20 selection:bg-indigo-500/30 selection:text-white"
    >
        {
            randomCenterDeco && (
                <img
                    src={randomCenterDeco}
                    alt=""
                    class="mask-fade-sides fixed bottom-[-200px] left-1/2 -translate-x-1/2 w-auto h-[1000px] opacity-10 grayscale pointer-events-none z-[-1]"
                />
            )
        }
        {
            randomLeftDeco && (
                <img
                    src={randomLeftDeco}
                    alt=""
                    class="fixed bottom-[-100px] left-0 -translate-x-[33%] w-auto h-[750px] opacity-10 grayscale pointer-events-none z-[-1]"
                />
            )
        }
        {
            randomRightDeco && (
                <img
                    src={randomRightDeco}
                    alt=""
                    class="fixed bottom-[-100px] right-0 translate-x-[33%] w-auto h-[750px] opacity-10 grayscale pointer-events-none z-[-1]"
                />
            )
        }
        <ProfileHeader
            profile={profile}
            bannerPath={bannerPath}
            avatarPath={avatarPath}
            stats={stats}
        />

        <main class="max-w-7xl mx-auto px-4 md:px-8">
            <SectionWrapper title="Hall of Fame">
                <HallOfFame
                    favorites={favorites}
                    characters={customCharacters}
                    likedCharacters={likedCharacters}
                    dislikedCharacters={dislikedCharacters}
                    interestedCharacters={interestedCharacters}
                    localLibrary={allContent}
                />
            </SectionWrapper>

            <div class="h-px w-full bg-white/10"></div>

            <SectionWrapper title="Historial">
                <MonthlyHistory works={monthlyWorks} chars={monthlyChars} />
            </SectionWrapper>

            <div class="h-px w-full bg-white/10"></div>

            <SectionWrapper title="Viaje en el Tiempo">
                <TimeTravel data={timeTravelData} />
            </SectionWrapper>

            <div class="h-px w-full bg-white/10"></div>

            <SectionWrapper title="Biblioteca">
                <LibraryGrid sagas={db.sagas} allContent={allContent} />
            </SectionWrapper>
        </main>
    </body>
</html>
